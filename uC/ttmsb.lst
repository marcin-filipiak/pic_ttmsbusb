CCS PCH C Compiler, Version 5.025, 5967               25-wrz-17 15:32

               Filename:   Z:\home\mfilipiak\Dropbox\Projekty\Elektronika\ttmsb_usb\uC\ttmsb.lst

               ROM used:   9378 bytes (29%)
                           Largest free fragment is 23390
               RAM used:   443 (22%) at main() level
                           515 (25%) worst case
               Stack used: 14 locations (7 in main + 7 for interrupts)
               Stack size: 31

*
0000:  GOTO   22F8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.5
0056:  GOTO   0060
005A:  BTFSC  FA1.5
005C:  GOTO   0F3A
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18F4550.h>  
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,03
00C0:  DATA 02,FF
00C2:  DATA FF,FF
00C4:  DATA FF,FF
00C6:  DATA FF,FF
00C8:  DATA FF,FF
00CA:  DATA FF,FF
00CC:  DATA FF,FF
00CE:  CLRF   FF7
00D0:  ADDLW  DE
00D2:  MOVWF  FF6
00D4:  MOVLW  00
00D6:  ADDWFC FF7,F
00D8:  TBLRD*+
00DA:  MOVF   FF5,W
00DC:  RETURN 0
00DE:  DATA 00,FF
00E0:  DATA 02,FF
00E2:  DATA FF,FF
00E4:  DATA FF,FF
00E6:  DATA FF,FF
00E8:  DATA FF,FF
00EA:  DATA FF,FF
00EC:  DATA FF,FF
00EE:  CLRF   FF7
00F0:  ADDLW  FE
00F2:  MOVWF  FF6
00F4:  MOVLW  00
00F6:  ADDWFC FF7,F
00F8:  TBLRD*+
00FA:  MOVF   FF5,W
00FC:  RETURN 0
00FE:  DATA 40,00
0100:  DATA 0B,00
0102:  DATA 40,00
0104:  DATA 00,00
0106:  DATA 00,00
0108:  DATA 00,00
010A:  DATA 00,00
010C:  DATA 00,00
010E:  DATA 00,00
0110:  DATA 00,00
0112:  DATA 00,00
0114:  DATA 00,00
0116:  DATA 00,00
0118:  DATA 00,00
011A:  DATA 00,00
011C:  DATA 00,00
011E:  CLRF   FF7
0120:  ADDLW  2E
0122:  MOVWF  FF6
0124:  MOVLW  01
0126:  ADDWFC FF7,F
0128:  TBLRD*+
012A:  MOVF   FF5,W
012C:  RETURN 0
012E:  DATA 40,00
0130:  DATA 00,00
0132:  DATA 40,00
0134:  DATA 00,00
0136:  DATA 00,00
0138:  DATA 00,00
013A:  DATA 00,00
013C:  DATA 00,00
013E:  DATA 00,00
0140:  DATA 00,00
0142:  DATA 00,00
0144:  DATA 00,00
0146:  DATA 00,00
0148:  DATA 00,00
014A:  DATA 00,00
014C:  DATA 00,00
014E:  CLRF   FF7
0150:  ADDLW  5E
0152:  MOVWF  FF6
0154:  MOVLW  01
0156:  ADDWFC FF7,F
0158:  TBLRD*+
015A:  MOVF   FF5,W
015C:  RETURN 0
015E:  DATA 09,02
0160:  DATA 43,00
0162:  DATA 02,01
0164:  DATA 00,80
0166:  DATA 96,09
0168:  DATA 04,00
016A:  DATA 00,01
016C:  DATA 02,02
016E:  DATA 01,00
0170:  DATA 05,24
0172:  DATA 00,10
0174:  DATA 01,04
0176:  DATA 24,02
0178:  DATA 02,05
017A:  DATA 24,06
017C:  DATA 00,01
017E:  DATA 05,24
0180:  DATA 01,00
0182:  DATA 01,07
0184:  DATA 05,81
0186:  DATA 03,0B
0188:  DATA 00,FA
018A:  DATA 09,04
018C:  DATA 01,00
018E:  DATA 02,0A
0190:  DATA 00,00
0192:  DATA 00,07
0194:  DATA 05,02
0196:  DATA 02,40
0198:  DATA 00,01
019A:  DATA 07,05
019C:  DATA 82,02
019E:  DATA 40,00
01A0:  DATA 01,00
01A2:  CLRF   FF7
01A4:  ADDLW  B2
01A6:  MOVWF  FF6
01A8:  MOVLW  01
01AA:  ADDWFC FF7,F
01AC:  TBLRD*+
01AE:  MOVF   FF5,W
01B0:  RETURN 0
01B2:  DATA 02,00
01B4:  CLRF   FF7
01B6:  ADDLW  C4
01B8:  MOVWF  FF6
01BA:  MOVLW  01
01BC:  ADDWFC FF7,F
01BE:  TBLRD*+
01C0:  MOVF   FF5,W
01C2:  RETURN 0
01C4:  DATA 12,17
01C6:  DATA 1B,20
01C8:  DATA FF,FF
01CA:  DATA FF,FF
01CC:  CLRF   FF7
01CE:  ADDLW  DC
01D0:  MOVWF  FF6
01D2:  MOVLW  01
01D4:  ADDWFC FF7,F
01D6:  TBLRD*+
01D8:  MOVF   FF5,W
01DA:  RETURN 0
01DC:  DATA 12,01
01DE:  DATA 10,01
01E0:  DATA 02,00
01E2:  DATA 00,40
01E4:  DATA 03,04
01E6:  DATA 01,60
01E8:  DATA 00,01
01EA:  DATA 01,02
01EC:  DATA 00,01
01EE:  CLRF   FF7
01F0:  ADDLW  FE
01F2:  MOVWF  FF6
01F4:  MOVLW  01
01F6:  ADDWFC FF7,F
01F8:  TBLRD*+
01FA:  MOVF   FF5,W
01FC:  RETURN 0
01FE:  DATA 04,03
0200:  DATA 09,04
0202:  DATA 08,03
0204:  DATA 43,00
0206:  DATA 43,00
0208:  DATA 53,00
020A:  DATA 20,03
020C:  DATA 43,00
020E:  DATA 43,00
0210:  DATA 53,00
0212:  DATA 20,00
0214:  DATA 55,00
0216:  DATA 53,00
0218:  DATA 42,00
021A:  DATA 20,00
021C:  DATA 74,00
021E:  DATA 6F,00
0220:  DATA 20,00
0222:  DATA 55,00
0224:  DATA 41,00
0226:  DATA 52,00
0228:  DATA 54,00
*
02BC:  MOVF   xDB,W
02BE:  MULWF  xDD
02C0:  MOVFF  FF3,01
02C4:  MOVFF  FF4,00
02C8:  MULWF  xDE
02CA:  MOVF   FF3,W
02CC:  ADDWF  00,F
02CE:  MOVF   xDC,W
02D0:  MULWF  xDD
02D2:  MOVF   FF3,W
02D4:  ADDWFC 00,W
02D6:  MOVWF  02
02D8:  RETURN 0
*
0FAC:  DATA 0A,54
0FAE:  DATA 54,4D
0FB0:  DATA 53,42
0FB2:  DATA 20,2D
0FB4:  DATA 20,4E
0FB6:  DATA 6F,77
0FB8:  DATA 65,45
0FBA:  DATA 6E,65
0FBC:  DATA 72,67
0FBE:  DATA 69,65
0FC0:  DATA 2E,6F
0FC2:  DATA 72,67
0FC4:  DATA 0A,00
0FC6:  DATA 0A,54
0FC8:  DATA 54,4D
0FCA:  DATA 53,42
0FCC:  DATA 20,2D
0FCE:  DATA 20,4E
0FD0:  DATA 6F,77
0FD2:  DATA 65,45
0FD4:  DATA 6E,65
0FD6:  DATA 72,67
0FD8:  DATA 69,65
0FDA:  DATA 2E,6F
0FDC:  DATA 72,67
0FDE:  DATA 0A,00
0FE0:  DATA 0A,64
0FE2:  DATA 61,79
0FE4:  DATA 00,00
0FE6:  DATA 0A,6D
0FE8:  DATA 6F,6E
0FEA:  DATA 74,68
0FEC:  DATA 00,00
0FEE:  DATA 0A,79
0FF0:  DATA 65,61
0FF2:  DATA 72,00
0FF4:  DATA 0A,68
0FF6:  DATA 6F,75
0FF8:  DATA 72,00
0FFA:  DATA 0A,6D
0FFC:  DATA 69,6E
0FFE:  DATA 00,00
1000:  DATA 0A,73
1002:  DATA 65,6B
1004:  DATA 00,00
1006:  DATA 22,25
1008:  DATA 64,22
100A:  DATA 3A,22
100C:  DATA 25,33
100E:  DATA 2E,31
1010:  DATA 66,22
1012:  DATA 00,00
*
10DA:  TBLRD*+
10DC:  MOVF   FF5,F
10DE:  BZ    10FA
10E0:  MOVFF  FF6,9B
10E4:  MOVFF  FF7,9C
10E8:  MOVF   FF5,W
10EA:  BTFSS  F9E.4
10EC:  BRA    10EA
10EE:  MOVWF  FAD
10F0:  MOVFF  9B,FF6
10F4:  MOVFF  9C,FF7
10F8:  BRA    10DA
10FA:  GOTO   11C4 (RETURN)
*
1158:  TBLRD*+
115A:  MOVF   FF5,F
115C:  BZ    1176
115E:  MOVFF  FF6,9B
1162:  MOVFF  FF7,9C
1166:  MOVFF  FF5,B4
116A:  RCALL  1146
116C:  MOVFF  9B,FF6
1170:  MOVFF  9C,FF7
1174:  BRA    1158
1176:  RETURN 0
*
12EE:  MOVF   xB5,W
12F0:  CLRF   01
12F2:  SUBWF  xB4,W
12F4:  BC    12FC
12F6:  MOVFF  B4,00
12FA:  BRA    1314
12FC:  CLRF   00
12FE:  MOVLW  08
1300:  MOVWF  xB6
1302:  RLCF   xB4,F
1304:  RLCF   00,F
1306:  MOVF   xB5,W
1308:  SUBWF  00,W
130A:  BTFSC  FD8.0
130C:  MOVWF  00
130E:  RLCF   01,F
1310:  DECFSZ xB6,F
1312:  BRA    1302
1314:  RETURN 0
*
16DC:  MOVLW  20
16DE:  BTFSS  xA8.4
16E0:  MOVLW  30
16E2:  MOVWF  xA9
16E4:  MOVFF  A7,00
16E8:  BTFSS  xA7.7
16EA:  BRA    16FC
16EC:  COMF   00,F
16EE:  INCF   00,F
16F0:  MOVFF  00,A7
16F4:  MOVLW  2D
16F6:  MOVWF  xA9
16F8:  BSF    xA8.7
16FA:  BSF    xA8.0
16FC:  MOVF   01,W
16FE:  MOVFF  A7,B4
1702:  MOVLW  64
1704:  MOVWF  xB5
1706:  RCALL  12EE
1708:  MOVFF  00,A7
170C:  MOVLW  30
170E:  ADDWF  01,W
1710:  MOVWF  xAA
1712:  MOVFF  A7,B4
1716:  MOVLW  0A
1718:  MOVWF  xB5
171A:  RCALL  12EE
171C:  MOVLW  30
171E:  ADDWF  00,W
1720:  MOVWF  xAC
1722:  MOVLW  30
1724:  ADDWF  01,W
1726:  MOVWF  xAB
1728:  MOVFF  A9,00
172C:  MOVLW  30
172E:  SUBWF  xAA,W
1730:  BZ    173A
1732:  BSF    xA8.1
1734:  BTFSC  xA8.7
1736:  BSF    xA8.2
1738:  BRA    175E
173A:  MOVFF  A9,AA
173E:  MOVLW  20
1740:  MOVWF  xA9
1742:  MOVLW  30
1744:  SUBWF  xAB,W
1746:  BZ    1750
1748:  BSF    xA8.0
174A:  BTFSC  xA8.7
174C:  BSF    xA8.1
174E:  BRA    175E
1750:  BTFSS  FD8.2
1752:  BSF    xA8.0
1754:  BNZ   175E
1756:  MOVFF  AA,AB
175A:  MOVLW  20
175C:  MOVWF  xAA
175E:  BTFSC  xA8.2
1760:  BRA    176C
1762:  BTFSC  xA8.1
1764:  BRA    1772
1766:  BTFSC  xA8.0
1768:  BRA    1778
176A:  BRA    177E
176C:  MOVFF  A9,B4
1770:  RCALL  1146
1772:  MOVFF  AA,B4
1776:  RCALL  1146
1778:  MOVFF  AB,B4
177C:  RCALL  1146
177E:  MOVFF  AC,B4
1782:  RCALL  1146
1784:  RETURN 0
*
1A0C:  CLRF   01
1A0E:  CLRF   02
1A10:  CLRF   00
1A12:  CLRF   03
1A14:  MOVF   xBA,W
1A16:  BNZ   1A1C
1A18:  MOVF   xB9,W
1A1A:  BZ    1A4C
1A1C:  MOVLW  10
1A1E:  MOVWF  xBB
1A20:  BCF    FD8.0
1A22:  RLCF   xB7,F
1A24:  RLCF   xB8,F
1A26:  RLCF   00,F
1A28:  RLCF   03,F
1A2A:  MOVF   xBA,W
1A2C:  SUBWF  03,W
1A2E:  BNZ   1A34
1A30:  MOVF   xB9,W
1A32:  SUBWF  00,W
1A34:  BNC   1A44
1A36:  MOVF   xB9,W
1A38:  SUBWF  00,F
1A3A:  BTFSS  FD8.0
1A3C:  DECF   03,F
1A3E:  MOVF   xBA,W
1A40:  SUBWF  03,F
1A42:  BSF    FD8.0
1A44:  RLCF   01,F
1A46:  RLCF   02,F
1A48:  DECFSZ xBB,F
1A4A:  BRA    1A20
1A4C:  GOTO   1B0A (RETURN)
*
1B42:  MOVFF  25,FEA
1B46:  MOVFF  24,FE9
1B4A:  MOVFF  B4,FEF
1B4E:  INCF   FE9,F
1B50:  BTFSC  FD8.2
1B52:  INCF   FEA,F
1B54:  CLRF   FEF
1B56:  INCF   24,F
1B58:  BTFSC  FD8.2
1B5A:  INCF   25,F
1B5C:  RETURN 0
1B5E:  MOVLW  20
1B60:  BTFSS  xAF.4
1B62:  MOVLW  30
1B64:  MOVWF  xB0
1B66:  MOVFF  AE,00
1B6A:  BTFSS  xAE.7
1B6C:  BRA    1B7E
1B6E:  COMF   00,F
1B70:  INCF   00,F
1B72:  MOVFF  00,AE
1B76:  MOVLW  2D
1B78:  MOVWF  xB0
1B7A:  BSF    xAF.7
1B7C:  BSF    xAF.0
1B7E:  MOVF   01,W
1B80:  MOVFF  AE,B4
1B84:  MOVLW  64
1B86:  MOVWF  xB5
1B88:  CALL   12EE
1B8C:  MOVFF  00,AE
1B90:  MOVLW  30
1B92:  ADDWF  01,W
1B94:  MOVWF  xB1
1B96:  MOVFF  AE,B4
1B9A:  MOVLW  0A
1B9C:  MOVWF  xB5
1B9E:  CALL   12EE
1BA2:  MOVLW  30
1BA4:  ADDWF  00,W
1BA6:  MOVWF  xB3
1BA8:  MOVLW  30
1BAA:  ADDWF  01,W
1BAC:  MOVWF  xB2
1BAE:  MOVFF  B0,00
1BB2:  MOVLW  30
1BB4:  SUBWF  xB1,W
1BB6:  BZ    1BC0
1BB8:  BSF    xAF.1
1BBA:  BTFSC  xAF.7
1BBC:  BSF    xAF.2
1BBE:  BRA    1BE4
1BC0:  MOVFF  B0,B1
1BC4:  MOVLW  20
1BC6:  MOVWF  xB0
1BC8:  MOVLW  30
1BCA:  SUBWF  xB2,W
1BCC:  BZ    1BD6
1BCE:  BSF    xAF.0
1BD0:  BTFSC  xAF.7
1BD2:  BSF    xAF.1
1BD4:  BRA    1BE4
1BD6:  BTFSS  FD8.2
1BD8:  BSF    xAF.0
1BDA:  BNZ   1BE4
1BDC:  MOVFF  B1,B2
1BE0:  MOVLW  20
1BE2:  MOVWF  xB1
1BE4:  BTFSC  xAF.2
1BE6:  BRA    1BF2
1BE8:  BTFSC  xAF.1
1BEA:  BRA    1BF8
1BEC:  BTFSC  xAF.0
1BEE:  BRA    1BFE
1BF0:  BRA    1C04
1BF2:  MOVFF  B0,B4
1BF6:  RCALL  1B42
1BF8:  MOVFF  B1,B4
1BFC:  RCALL  1B42
1BFE:  MOVFF  B2,B4
1C02:  RCALL  1B42
1C04:  MOVFF  B3,B4
1C08:  RCALL  1B42
1C0A:  GOTO   1D06 (RETURN)
1C0E:  MOVLW  20
1C10:  BTFSS  xAF.4
1C12:  MOVLW  30
1C14:  MOVWF  xB0
1C16:  MOVFF  AE,00
1C1A:  BTFSS  xAE.7
1C1C:  BRA    1C2E
1C1E:  COMF   00,F
1C20:  INCF   00,F
1C22:  MOVFF  00,AE
1C26:  MOVLW  2D
1C28:  MOVWF  xB0
1C2A:  BSF    xAF.7
1C2C:  BSF    xAF.0
1C2E:  MOVF   01,W
1C30:  MOVFF  AE,B4
1C34:  MOVLW  64
1C36:  MOVWF  xB5
1C38:  CALL   12EE
1C3C:  MOVFF  00,AE
1C40:  MOVLW  30
1C42:  ADDWF  01,W
1C44:  MOVWF  xB1
1C46:  MOVFF  AE,B4
1C4A:  MOVLW  0A
1C4C:  MOVWF  xB5
1C4E:  CALL   12EE
1C52:  MOVLW  30
1C54:  ADDWF  00,W
1C56:  MOVWF  xB3
1C58:  MOVLW  30
1C5A:  ADDWF  01,W
1C5C:  MOVWF  xB2
1C5E:  MOVFF  B0,00
1C62:  MOVLW  30
1C64:  SUBWF  xB1,W
1C66:  BZ    1C70
1C68:  BSF    xAF.1
1C6A:  BTFSC  xAF.7
1C6C:  BSF    xAF.2
1C6E:  BRA    1C94
1C70:  BTFSC  xAF.2
1C72:  BRA    1C94
1C74:  MOVFF  B0,B1
1C78:  BTFSC  xAF.1
1C7A:  BRA    1C84
1C7C:  MOVLW  30
1C7E:  SUBWF  xB2,W
1C80:  BZ    1C8A
1C82:  BSF    xAF.0
1C84:  BTFSC  xAF.7
1C86:  BSF    xAF.1
1C88:  BRA    1C94
1C8A:  BTFSS  FD8.2
1C8C:  BSF    xAF.0
1C8E:  BTFSC  FD8.2
1C90:  MOVFF  B1,B2
1C94:  BTFSC  xAF.2
1C96:  BRA    1CA2
1C98:  BTFSC  xAF.1
1C9A:  BRA    1CA8
1C9C:  BTFSC  xAF.0
1C9E:  BRA    1CAE
1CA0:  BRA    1CB4
1CA2:  MOVFF  B0,B4
1CA6:  RCALL  1B42
1CA8:  MOVFF  B1,B4
1CAC:  RCALL  1B42
1CAE:  MOVFF  B2,B4
1CB2:  RCALL  1B42
1CB4:  MOVFF  B3,B4
1CB8:  RCALL  1B42
1CBA:  GOTO   1D16 (RETURN)
*
1D1A:  MOVLW  8E
1D1C:  MOVWF  00
1D1E:  MOVFF  A8,01
1D22:  MOVFF  A7,02
1D26:  CLRF   03
1D28:  MOVF   01,F
1D2A:  BNZ   1D3E
1D2C:  MOVFF  02,01
1D30:  CLRF   02
1D32:  MOVLW  08
1D34:  SUBWF  00,F
1D36:  MOVF   01,F
1D38:  BNZ   1D3E
1D3A:  CLRF   00
1D3C:  BRA    1D4E
1D3E:  BCF    FD8.0
1D40:  BTFSC  01.7
1D42:  BRA    1D4C
1D44:  RLCF   02,F
1D46:  RLCF   01,F
1D48:  DECF   00,F
1D4A:  BRA    1D3E
1D4C:  BCF    01.7
1D4E:  GOTO   1EBA (RETURN)
1D52:  MOVF   xAB,W
1D54:  BTFSC  FD8.2
1D56:  BRA    1EA2
1D58:  MOVWF  xB7
1D5A:  MOVF   xAF,W
1D5C:  BTFSC  FD8.2
1D5E:  BRA    1EA2
1D60:  SUBWF  xB7,F
1D62:  BNC   1D6E
1D64:  MOVLW  7F
1D66:  ADDWF  xB7,F
1D68:  BTFSC  FD8.0
1D6A:  BRA    1EA2
1D6C:  BRA    1D7A
1D6E:  MOVLW  81
1D70:  SUBWF  xB7,F
1D72:  BTFSS  FD8.0
1D74:  BRA    1EA2
1D76:  BTFSC  FD8.2
1D78:  BRA    1EA2
1D7A:  MOVFF  B7,00
1D7E:  CLRF   01
1D80:  CLRF   02
1D82:  CLRF   03
1D84:  CLRF   xB6
1D86:  MOVFF  AC,B5
1D8A:  BSF    xB5.7
1D8C:  MOVFF  AD,B4
1D90:  MOVFF  AE,B3
1D94:  MOVLW  19
1D96:  MOVWF  xB7
1D98:  MOVF   xB2,W
1D9A:  SUBWF  xB3,F
1D9C:  BC    1DB8
1D9E:  MOVLW  01
1DA0:  SUBWF  xB4,F
1DA2:  BC    1DB8
1DA4:  SUBWF  xB5,F
1DA6:  BC    1DB8
1DA8:  SUBWF  xB6,F
1DAA:  BC    1DB8
1DAC:  INCF   xB6,F
1DAE:  INCF   xB5,F
1DB0:  INCF   xB4,F
1DB2:  MOVF   xB2,W
1DB4:  ADDWF  xB3,F
1DB6:  BRA    1E08
1DB8:  MOVF   xB1,W
1DBA:  SUBWF  xB4,F
1DBC:  BC    1DE2
1DBE:  MOVLW  01
1DC0:  SUBWF  xB5,F
1DC2:  BC    1DE2
1DC4:  SUBWF  xB6,F
1DC6:  BC    1DE2
1DC8:  INCF   xB6,F
1DCA:  INCF   xB5,F
1DCC:  MOVF   xB1,W
1DCE:  ADDWF  xB4,F
1DD0:  MOVF   xB2,W
1DD2:  ADDWF  xB3,F
1DD4:  BNC   1E08
1DD6:  INCF   xB4,F
1DD8:  BNZ   1E08
1DDA:  INCF   xB5,F
1DDC:  BNZ   1E08
1DDE:  INCF   xB6,F
1DE0:  BRA    1E08
1DE2:  MOVF   xB0,W
1DE4:  IORLW  80
1DE6:  SUBWF  xB5,F
1DE8:  BC    1E06
1DEA:  MOVLW  01
1DEC:  SUBWF  xB6,F
1DEE:  BC    1E06
1DF0:  INCF   xB6,F
1DF2:  MOVF   xB0,W
1DF4:  IORLW  80
1DF6:  ADDWF  xB5,F
1DF8:  MOVF   xB1,W
1DFA:  ADDWF  xB4,F
1DFC:  BNC   1DD0
1DFE:  INCF   xB5,F
1E00:  BNZ   1DD0
1E02:  INCF   xB6,F
1E04:  BRA    1DD0
1E06:  BSF    03.0
1E08:  DECFSZ xB7,F
1E0A:  BRA    1E0E
1E0C:  BRA    1E24
1E0E:  BCF    FD8.0
1E10:  RLCF   xB3,F
1E12:  RLCF   xB4,F
1E14:  RLCF   xB5,F
1E16:  RLCF   xB6,F
1E18:  BCF    FD8.0
1E1A:  RLCF   03,F
1E1C:  RLCF   02,F
1E1E:  RLCF   01,F
1E20:  RLCF   xB8,F
1E22:  BRA    1D98
1E24:  BTFSS  xB8.0
1E26:  BRA    1E34
1E28:  BCF    FD8.0
1E2A:  RRCF   01,F
1E2C:  RRCF   02,F
1E2E:  RRCF   03,F
1E30:  RRCF   xB8,F
1E32:  BRA    1E38
1E34:  DECF   00,F
1E36:  BZ    1EA2
1E38:  BTFSC  xB8.7
1E3A:  BRA    1E78
1E3C:  BCF    FD8.0
1E3E:  RLCF   xB3,F
1E40:  RLCF   xB4,F
1E42:  RLCF   xB5,F
1E44:  RLCF   xB6,F
1E46:  MOVF   xB2,W
1E48:  SUBWF  xB3,F
1E4A:  BC    1E5A
1E4C:  MOVLW  01
1E4E:  SUBWF  xB4,F
1E50:  BC    1E5A
1E52:  SUBWF  xB5,F
1E54:  BC    1E5A
1E56:  SUBWF  xB6,F
1E58:  BNC   1E8E
1E5A:  MOVF   xB1,W
1E5C:  SUBWF  xB4,F
1E5E:  BC    1E6A
1E60:  MOVLW  01
1E62:  SUBWF  xB5,F
1E64:  BC    1E6A
1E66:  SUBWF  xB6,F
1E68:  BNC   1E8E
1E6A:  MOVF   xB0,W
1E6C:  IORLW  80
1E6E:  SUBWF  xB5,F
1E70:  BC    1E78
1E72:  MOVLW  01
1E74:  SUBWF  xB6,F
1E76:  BNC   1E8E
1E78:  INCF   03,F
1E7A:  BNZ   1E8E
1E7C:  INCF   02,F
1E7E:  BNZ   1E8E
1E80:  INCF   01,F
1E82:  BNZ   1E8E
1E84:  INCF   00,F
1E86:  BZ    1EA2
1E88:  RRCF   01,F
1E8A:  RRCF   02,F
1E8C:  RRCF   03,F
1E8E:  MOVFF  AC,B7
1E92:  MOVF   xB0,W
1E94:  XORWF  xB7,F
1E96:  BTFSS  xB7.7
1E98:  BRA    1E9E
1E9A:  BSF    01.7
1E9C:  BRA    1EAA
1E9E:  BCF    01.7
1EA0:  BRA    1EAA
1EA2:  CLRF   00
1EA4:  CLRF   01
1EA6:  CLRF   02
1EA8:  CLRF   03
1EAA:  GOTO   1EE6 (RETURN)
*
1EEA:  TBLRD*+
1EEC:  MOVFF  FF6,A8
1EF0:  MOVFF  FF7,A9
1EF4:  MOVFF  FF5,B4
1EF8:  CALL   1146
1EFC:  MOVFF  A8,FF6
1F00:  MOVFF  A9,FF7
1F04:  DECFSZ xA7,F
1F06:  BRA    1EEA
1F08:  GOTO   22BE (RETURN)
1F0C:  MOVF   xB4,W
1F0E:  BTFSC  FD8.2
1F10:  BRA    1FF4
1F12:  MOVWF  00
1F14:  MOVF   xB8,W
1F16:  BTFSC  FD8.2
1F18:  BRA    1FF4
1F1A:  ADDWF  00,F
1F1C:  BNC   1F26
1F1E:  MOVLW  81
1F20:  ADDWF  00,F
1F22:  BC    1FF4
1F24:  BRA    1F2E
1F26:  MOVLW  7F
1F28:  SUBWF  00,F
1F2A:  BNC   1FF4
1F2C:  BZ    1FF4
1F2E:  MOVFF  B5,BC
1F32:  MOVF   xB9,W
1F34:  XORWF  xBC,F
1F36:  BSF    xB5.7
1F38:  BSF    xB9.7
1F3A:  MOVF   xB7,W
1F3C:  MULWF  xBB
1F3E:  MOVFF  FF4,BE
1F42:  MOVF   xB6,W
1F44:  MULWF  xBA
1F46:  MOVFF  FF4,03
1F4A:  MOVFF  FF3,BD
1F4E:  MULWF  xBB
1F50:  MOVF   FF3,W
1F52:  ADDWF  xBE,F
1F54:  MOVF   FF4,W
1F56:  ADDWFC xBD,F
1F58:  MOVLW  00
1F5A:  ADDWFC 03,F
1F5C:  MOVF   xB7,W
1F5E:  MULWF  xBA
1F60:  MOVF   FF3,W
1F62:  ADDWF  xBE,F
1F64:  MOVF   FF4,W
1F66:  ADDWFC xBD,F
1F68:  MOVLW  00
1F6A:  CLRF   02
1F6C:  ADDWFC 03,F
1F6E:  ADDWFC 02,F
1F70:  MOVF   xB5,W
1F72:  MULWF  xBB
1F74:  MOVF   FF3,W
1F76:  ADDWF  xBD,F
1F78:  MOVF   FF4,W
1F7A:  ADDWFC 03,F
1F7C:  MOVLW  00
1F7E:  ADDWFC 02,F
1F80:  MOVF   xB5,W
1F82:  MULWF  xBA
1F84:  MOVF   FF3,W
1F86:  ADDWF  03,F
1F88:  MOVF   FF4,W
1F8A:  ADDWFC 02,F
1F8C:  MOVLW  00
1F8E:  CLRF   01
1F90:  ADDWFC 01,F
1F92:  MOVF   xB7,W
1F94:  MULWF  xB9
1F96:  MOVF   FF3,W
1F98:  ADDWF  xBD,F
1F9A:  MOVF   FF4,W
1F9C:  ADDWFC 03,F
1F9E:  MOVLW  00
1FA0:  ADDWFC 02,F
1FA2:  ADDWFC 01,F
1FA4:  MOVF   xB6,W
1FA6:  MULWF  xB9
1FA8:  MOVF   FF3,W
1FAA:  ADDWF  03,F
1FAC:  MOVF   FF4,W
1FAE:  ADDWFC 02,F
1FB0:  MOVLW  00
1FB2:  ADDWFC 01,F
1FB4:  MOVF   xB5,W
1FB6:  MULWF  xB9
1FB8:  MOVF   FF3,W
1FBA:  ADDWF  02,F
1FBC:  MOVF   FF4,W
1FBE:  ADDWFC 01,F
1FC0:  INCF   00,F
1FC2:  BTFSC  01.7
1FC4:  BRA    1FD0
1FC6:  RLCF   xBD,F
1FC8:  RLCF   03,F
1FCA:  RLCF   02,F
1FCC:  RLCF   01,F
1FCE:  DECF   00,F
1FD0:  MOVLW  00
1FD2:  BTFSS  xBD.7
1FD4:  BRA    1FEA
1FD6:  INCF   03,F
1FD8:  ADDWFC 02,F
1FDA:  ADDWFC 01,F
1FDC:  MOVF   01,W
1FDE:  BNZ   1FEA
1FE0:  MOVF   02,W
1FE2:  BNZ   1FEA
1FE4:  MOVF   03,W
1FE6:  BNZ   1FEA
1FE8:  INCF   00,F
1FEA:  BTFSC  xBC.7
1FEC:  BSF    01.7
1FEE:  BTFSS  xBC.7
1FF0:  BCF    01.7
1FF2:  BRA    1FFC
1FF4:  CLRF   00
1FF6:  CLRF   01
1FF8:  CLRF   02
1FFA:  CLRF   03
1FFC:  GOTO   20F6 (RETURN)
2000:  MOVF   xB4,W
2002:  SUBLW  B6
2004:  MOVWF  xB4
2006:  CLRF   03
2008:  MOVFF  B5,B8
200C:  BSF    xB5.7
200E:  BCF    FD8.0
2010:  RRCF   xB5,F
2012:  RRCF   xB6,F
2014:  RRCF   xB7,F
2016:  RRCF   03,F
2018:  RRCF   02,F
201A:  RRCF   01,F
201C:  RRCF   00,F
201E:  DECFSZ xB4,F
2020:  BRA    200E
2022:  BTFSS  xB8.7
2024:  BRA    203C
2026:  COMF   00,F
2028:  COMF   01,F
202A:  COMF   02,F
202C:  COMF   03,F
202E:  INCF   00,F
2030:  BTFSC  FD8.2
2032:  INCF   01,F
2034:  BTFSC  FD8.2
2036:  INCF   02,F
2038:  BTFSC  FD8.2
203A:  INCF   03,F
203C:  GOTO   211C (RETURN)
2040:  BTFSC  FD8.1
2042:  BRA    204A
2044:  CLRF   FEA
2046:  MOVLW  BC
2048:  MOVWF  FE9
204A:  CLRF   00
204C:  CLRF   01
204E:  CLRF   02
2050:  CLRF   03
2052:  CLRF   xBC
2054:  CLRF   xBD
2056:  CLRF   xBE
2058:  CLRF   xBF
205A:  MOVF   xBB,W
205C:  IORWF  xBA,W
205E:  IORWF  xB9,W
2060:  IORWF  xB8,W
2062:  BZ    20BC
2064:  MOVLW  20
2066:  MOVWF  xC0
2068:  BCF    FD8.0
206A:  RLCF   xB4,F
206C:  RLCF   xB5,F
206E:  RLCF   xB6,F
2070:  RLCF   xB7,F
2072:  RLCF   xBC,F
2074:  RLCF   xBD,F
2076:  RLCF   xBE,F
2078:  RLCF   xBF,F
207A:  MOVF   xBB,W
207C:  SUBWF  xBF,W
207E:  BNZ   2090
2080:  MOVF   xBA,W
2082:  SUBWF  xBE,W
2084:  BNZ   2090
2086:  MOVF   xB9,W
2088:  SUBWF  xBD,W
208A:  BNZ   2090
208C:  MOVF   xB8,W
208E:  SUBWF  xBC,W
2090:  BNC   20B0
2092:  MOVF   xB8,W
2094:  SUBWF  xBC,F
2096:  MOVF   xB9,W
2098:  BTFSS  FD8.0
209A:  INCFSZ xB9,W
209C:  SUBWF  xBD,F
209E:  MOVF   xBA,W
20A0:  BTFSS  FD8.0
20A2:  INCFSZ xBA,W
20A4:  SUBWF  xBE,F
20A6:  MOVF   xBB,W
20A8:  BTFSS  FD8.0
20AA:  INCFSZ xBB,W
20AC:  SUBWF  xBF,F
20AE:  BSF    FD8.0
20B0:  RLCF   00,F
20B2:  RLCF   01,F
20B4:  RLCF   02,F
20B6:  RLCF   03,F
20B8:  DECFSZ xC0,F
20BA:  BRA    2068
20BC:  MOVFF  BC,FEF
20C0:  MOVFF  BD,FEC
20C4:  MOVFF  BE,FEC
20C8:  MOVFF  BF,FEC
20CC:  RETURN 0
20CE:  MOVF   FE9,W
20D0:  MOVWF  xAC
20D2:  MOVF   xAB,W
20D4:  MOVWF  xAE
20D6:  BZ    210A
20D8:  MOVFF  AA,B7
20DC:  MOVFF  A9,B6
20E0:  MOVFF  A8,B5
20E4:  MOVFF  A7,B4
20E8:  CLRF   xBB
20EA:  CLRF   xBA
20EC:  MOVLW  20
20EE:  MOVWF  xB9
20F0:  MOVLW  82
20F2:  MOVWF  xB8
20F4:  BRA    1F0C
20F6:  MOVFF  03,AA
20FA:  MOVFF  02,A9
20FE:  MOVFF  01,A8
2102:  MOVFF  00,A7
2106:  DECFSZ xAE,F
2108:  BRA    20D8
210A:  MOVFF  AA,B7
210E:  MOVFF  A9,B6
2112:  MOVFF  A8,B5
2116:  MOVFF  A7,B4
211A:  BRA    2000
211C:  MOVFF  03,AA
2120:  MOVFF  02,A9
2124:  MOVFF  01,A8
2128:  MOVFF  00,A7
212C:  BTFSS  xAA.7
212E:  BRA    214A
2130:  DECF   xAC,F
2132:  BSF    xAC.5
2134:  COMF   xA7,F
2136:  COMF   xA8,F
2138:  COMF   xA9,F
213A:  COMF   xAA,F
213C:  INCF   xA7,F
213E:  BTFSC  FD8.2
2140:  INCF   xA8,F
2142:  BTFSC  FD8.2
2144:  INCF   xA9,F
2146:  BTFSC  FD8.2
2148:  INCF   xAA,F
214A:  MOVLW  3B
214C:  MOVWF  xB3
214E:  MOVLW  9A
2150:  MOVWF  xB2
2152:  MOVLW  CA
2154:  MOVWF  xB1
2156:  CLRF   xB0
2158:  MOVLW  0A
215A:  MOVWF  xAE
215C:  MOVF   xAB,W
215E:  BTFSC  FD8.2
2160:  INCF   xAC,F
2162:  BSF    FD8.1
2164:  CLRF   FEA
2166:  MOVLW  A7
2168:  MOVWF  FE9
216A:  MOVFF  AA,B7
216E:  MOVFF  A9,B6
2172:  MOVFF  A8,B5
2176:  MOVFF  A7,B4
217A:  MOVFF  B3,BB
217E:  MOVFF  B2,BA
2182:  MOVFF  B1,B9
2186:  MOVFF  B0,B8
218A:  RCALL  2040
218C:  MOVF   01,W
218E:  MOVF   00,F
2190:  BNZ   21B0
2192:  INCF   xAB,W
2194:  SUBWF  xAE,W
2196:  BZ    21B0
2198:  MOVF   xAC,W
219A:  BZ    21B4
219C:  ANDLW  0F
219E:  SUBWF  xAE,W
21A0:  BZ    21A4
21A2:  BC    221A
21A4:  BTFSC  xAC.7
21A6:  BRA    221A
21A8:  BTFSC  xAC.6
21AA:  BRA    21B4
21AC:  MOVLW  20
21AE:  BRA    2210
21B0:  MOVLW  20
21B2:  ANDWF  xAC,F
21B4:  BTFSS  xAC.5
21B6:  BRA    21D2
21B8:  BCF    xAC.5
21BA:  MOVF   xAB,W
21BC:  BTFSS  FD8.2
21BE:  DECF   xAC,F
21C0:  MOVF   00,W
21C2:  MOVWF  xAC
21C4:  MOVLW  2D
21C6:  MOVWF  xB4
21C8:  CALL   1146
21CC:  MOVF   xAC,W
21CE:  MOVWF  00
21D0:  CLRF   xAC
21D2:  MOVF   xAB,W
21D4:  SUBWF  xAE,W
21D6:  BNZ   21EE
21D8:  MOVF   00,W
21DA:  MOVWF  xAC
21DC:  MOVLW  2E
21DE:  MOVWF  xB4
21E0:  CALL   1146
21E4:  MOVF   xAC,W
21E6:  MOVWF  00
21E8:  MOVLW  20
21EA:  ANDWF  xAC,F
21EC:  MOVLW  00
21EE:  MOVLW  30
21F0:  BTFSS  xAC.5
21F2:  BRA    2210
21F4:  BCF    xAC.5
21F6:  MOVF   xAB,W
21F8:  BTFSS  FD8.2
21FA:  DECF   xAC,F
21FC:  MOVF   00,W
21FE:  MOVWF  xAC
2200:  MOVLW  2D
2202:  MOVWF  xB4
2204:  CALL   1146
2208:  MOVF   xAC,W
220A:  MOVWF  00
220C:  CLRF   xAC
220E:  MOVLW  30
2210:  ADDWF  00,F
2212:  MOVFF  00,B4
2216:  CALL   1146
221A:  BCF    FD8.1
221C:  MOVFF  B3,B7
2220:  MOVFF  B2,B6
2224:  MOVFF  B1,B5
2228:  MOVFF  B0,B4
222C:  CLRF   xBB
222E:  CLRF   xBA
2230:  CLRF   xB9
2232:  MOVLW  0A
2234:  MOVWF  xB8
2236:  RCALL  2040
2238:  MOVFF  03,B3
223C:  MOVFF  02,B2
2240:  MOVFF  01,B1
2244:  MOVFF  00,B0
2248:  DECFSZ xAE,F
224A:  BRA    2162
224C:  GOTO   22D8 (RETURN)
....................  
.................... #list 
....................  
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN  
....................  
.................... //#fuses BROWNOUT     //Reset when brownout detected  
.................... //#fuses BORV20           //Brownout reset at 2.0V 
....................  
.................... #use delay(clock=48000000)  
*
1014:  CLRF   FEA
1016:  MOVLW  B6
1018:  MOVWF  FE9
101A:  MOVF   FEF,W
101C:  BZ    103A
101E:  MOVLW  0F
1020:  MOVWF  01
1022:  CLRF   00
1024:  DECFSZ 00,F
1026:  BRA    1024
1028:  DECFSZ 01,F
102A:  BRA    1022
102C:  MOVLW  8F
102E:  MOVWF  00
1030:  DECFSZ 00,F
1032:  BRA    1030
1034:  NOP   
1036:  DECFSZ FEF,F
1038:  BRA    101E
103A:  RETURN 0
*
1786:  MOVLW  01
1788:  SUBWF  xBC,F
178A:  BNC   17A4
178C:  CLRF   FEA
178E:  MOVLW  BC
1790:  MOVWF  FE9
1792:  MOVF   FEF,W
1794:  BZ    17A4
1796:  MOVLW  02
1798:  MOVWF  00
179A:  DECFSZ 00,F
179C:  BRA    179A
179E:  BRA    17A0
17A0:  DECFSZ FEF,F
17A2:  BRA    1796
17A4:  RETURN 0
....................  
....................  
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7) 
....................  
.................... #use i2c(master,sda=PIN_B0,scl=PIN_B1) 
....................  
....................  
.................... #define LED_GREEN  PIN_E2  
.................... #define LED_RED    PIN_C0  
.................... #define LED_ON output_low  
.................... #define LED_OFF output_high  
.................... #define DQ PIN_B3 //dane 1wire 
....................  
.................... #define DS1820_DATAPIN PIN_B3 
.................... #include "drv\ds1820.h" 
....................    /*** FILEHEADER **************************************************************** 
....................  * 
....................  *    FILENAME:    ds1820.h 
....................  *    DATE:        25.02.2005 
....................  *    AUTHOR:      Christian Stadler 
....................  * 
....................  *    DESCRIPTION: Driver for DS1820 1-Wire Temperature sensor (Dallas) 
....................  * 
....................  ******************************************************************************/ 
....................  
.................... /*** HISTORY OF CHANGE ********************************************************* 
....................  * 
....................  *    $Log: /pic/_drv/ds1820.h $ 
....................  *  
....................  * 9     13.11.10 20:02 Stadler 
....................  * - changed interrupt lock and delay functions to #defines to remove 
....................  * function call overhead 
....................  *  
....................  * 8     6.11.10 10:24 Stadler 
....................  * - adjusted 1-wire timing 
....................  *  
....................  * 7     5.11.10 22:55 Stadler 
....................  * - changed driver API 
....................  *  
....................  * 6     5.11.10 21:59 Stadler 
....................  * - added DS18B20 support 
....................  * - fixed problem with ROM search algorithm 
....................  *  
....................  * 5     2.11.10 20:25 Stadler 
....................  * - changed function DS1820_FindFirstDev to DS1820_FindFirstDevice 
....................  * - changed function DS1820_FindNextDev to DS1820_FindNextDevice 
....................  * - updated code style 
....................  *  
....................  * 4     31.10.10 17:12 Stadler 
....................  * - introduced DS1820_DelayUs 
....................  *  
....................  * 3     25.10.10 13:09 Stadler 
....................  * - added interrupt lock 
....................  *  
....................  * 2     12.03.05 11:24 Stadler 
....................  * - added EEPROM write function 
....................  * - added "Search ROM Algorithm" to control multiple devices 
....................  * 
....................  * 1     26.02.05 18:18 Stadler 
....................  * Driver for DS1820 1-Wire Temperature sensor (Dallas) 
....................  * 
....................  ******************************************************************************/ 
....................  
.................... #ifndef _DS1820_H 
.................... #define _DS1820_H 
....................  
....................  
.................... /* check configuration of driver  
.................... #ifndef DS1820_DATAPIN 
.................... #error DS1820 data pin not defined! 
.................... #endif 
.................... */ 
....................  
.................... #define TEMP_RES              0x100 /* temperature resolution => 1/256°C = 0.0039°C */ 
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                         DS1820 Timing Parameters                           */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
.................... #define DS1820_RST_PULSE       480   /* master reset pulse time in [us] */ 
.................... #define DS1820_MSTR_BITSTART   2     /* delay time for bit start by master */ 
.................... #define DS1820_PRESENCE_WAIT   40    /* delay after master reset pulse in [us] */ 
.................... #define DS1820_PRESENCE_FIN    480   /* dealy after reading of presence pulse [us] */ 
.................... #define DS1820_BITREAD_DLY     5     /* bit read delay */ 
.................... #define DS1820_BITWRITE_DLY    100   /* bit write delay */ 
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                            DS1820 Registers                                */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
.................... #define DS1820_REG_TEMPLSB    0 
.................... #define DS1820_REG_TEMPMSB    1 
.................... #define DS1820_REG_CNTREMAIN  6 
.................... #define DS1820_REG_CNTPERSEC  7 
.................... #define DS1820_SCRPADMEM_LEN  9     /* length of scratchpad memory */ 
....................  
.................... #define DS1820_ADDR_LEN       8 
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                            DS1820 Commands                                 */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
.................... #define DS1820_CMD_SEARCHROM     0xF0 
.................... #define DS1820_CMD_READROM       0x33 
.................... #define DS1820_CMD_MATCHROM      0x55 
.................... #define DS1820_CMD_SKIPROM       0xCC 
.................... #define DS1820_CMD_ALARMSEARCH   0xEC 
.................... #define DS1820_CMD_CONVERTTEMP   0x44 
.................... #define DS1820_CMD_WRITESCRPAD   0x4E 
.................... #define DS1820_CMD_READSCRPAD    0xBE 
.................... #define DS1820_CMD_COPYSCRPAD    0x48 
.................... #define DS1820_CMD_RECALLEE      0xB8 
....................  
....................  
.................... #define DS1820_FAMILY_CODE_DS18B20      0x28 
.................... #define DS1820_FAMILY_CODE_DS18S20      0x10 
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                            static variables                                */ 
.................... /* -------------------------------------------------------------------------- */ 
.................... #define BYTE int  
.................... #define bool short int  
....................  
.................... #define uint8 int8 
.................... #define uint16 int16 
.................... #define sint8 int8 
.................... #define sint16 int16 
....................  
.................... static bool bDoneFlag; 
.................... static uint8 nLastDiscrepancy_u8; 
.................... static uint8 nRomAddr_au8[DS1820_ADDR_LEN]; 
....................  
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                           Low-Level Functions                              */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_DelayUs 
....................  * PURPOSE:    Delay for the given number of micro seconds. 
....................  * 
....................  * INPUT:      dly_us      number of micro seconds to delay 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... #define DS1820_DelayUs(dly_us)       delay_us(dly_us) 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_DelayMs 
....................  * PURPOSE:    Delay for the given number of milliseconds. 
....................  * 
....................  * INPUT:      dly_ms      number of milliseconds to delay 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... #define DS1820_DelayMs(dly_ms)   delay_ms(dly_ms) 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_DisableInterrupts 
....................  * PURPOSE:    Disable interrupts 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... #ifdef DS1820_INTERRUPT_LOCK 
.................... #define DS1820_DisableInterrupts()  disable_interrupts(GLOBAL) 
.................... #else 
.................... #define DS1820_DisableInterrupts() 
.................... #endif 
....................  
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_EnableInterrupts 
....................  * PURPOSE:    Enable interrupts 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... #ifdef DS1820_INTERRUPT_LOCK 
.................... #define DS1820_EnableInterrupts()   enable_interrupts(GLOBAL) 
.................... #else 
.................... #define DS1820_EnableInterrupts() 
.................... #endif 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_Reset 
....................  * PURPOSE:    Initializes the DS1820 device. 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     - 
....................  * RETURN:     FALSE if at least one device is on the 1-wire bus, TRUE otherwise 
....................  ******************************************************************************/ 
.................... bool DS1820_Reset(void) 
.................... { 
....................    bool bPresPulse; 
....................  
....................    DS1820_DisableInterrupts(); 
....................     
....................    /* reset pulse */ 
....................    output_low(DS1820_DATAPIN); 
17A6:  BCF    F93.3
17A8:  BCF    F8A.3
....................    DS1820_DelayUs(DS1820_RST_PULSE); 
17AA:  MOVLW  02
17AC:  MOVWF  xB6
17AE:  MOVLW  F0
17B0:  MOVWF  xBC
17B2:  RCALL  1786
17B4:  DECFSZ xB6,F
17B6:  BRA    17AE
....................    output_high(DS1820_DATAPIN); 
17B8:  BCF    F93.3
17BA:  BSF    F8A.3
....................  
....................    /* wait until pullup pull 1-wire bus to high */ 
....................    DS1820_DelayUs(DS1820_PRESENCE_WAIT); 
17BC:  MOVLW  9F
17BE:  MOVWF  00
17C0:  DECFSZ 00,F
17C2:  BRA    17C0
17C4:  BRA    17C6
....................  
....................    /* get presence pulse */ 
....................    bPresPulse = input(DS1820_DATAPIN); 
17C6:  BSF    F93.3
17C8:  BCF    xB5.0
17CA:  BTFSC  F81.3
17CC:  BSF    xB5.0
....................  
....................    DS1820_DelayUs(424); 
17CE:  MOVLW  02
17D0:  MOVWF  xB6
17D2:  MOVLW  D4
17D4:  MOVWF  xBC
17D6:  RCALL  1786
17D8:  DECFSZ xB6,F
17DA:  BRA    17D2
....................     
....................    DS1820_EnableInterrupts(); 
....................  
....................    return bPresPulse; 
17DC:  MOVLW  00
17DE:  BTFSC  xB5.0
17E0:  MOVLW  01
17E2:  MOVWF  01
17E4:  RETURN 0
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_ReadBit 
....................  * PURPOSE:    Reads a single bit from the DS1820 device. 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     - 
....................  * RETURN:     bool        value of the bit which as been read form the DS1820 
....................  ******************************************************************************/ 
.................... bool DS1820_ReadBit(void) 
.................... { 
....................    bool bBit; 
....................  
....................    DS1820_DisableInterrupts(); 
....................     
....................    output_low(DS1820_DATAPIN); 
*
1838:  BCF    F93.3
183A:  BCF    F8A.3
....................    DS1820_DelayUs(DS1820_MSTR_BITSTART); 
183C:  MOVLW  07
183E:  MOVWF  00
1840:  DECFSZ 00,F
1842:  BRA    1840
1844:  BRA    1846
....................    input(DS1820_DATAPIN); 
1846:  BSF    F93.3
....................    DS1820_DelayUs(DS1820_BITREAD_DLY); 
1848:  MOVLW  13
184A:  MOVWF  00
184C:  DECFSZ 00,F
184E:  BRA    184C
1850:  BRA    1852
....................  
....................    bBit = input(DS1820_DATAPIN); 
1852:  BSF    F93.3
1854:  BCF    xB9.0
1856:  BTFSC  F81.3
1858:  BSF    xB9.0
....................     
....................    DS1820_EnableInterrupts(); 
....................  
....................    return (bBit); 
185A:  MOVLW  00
185C:  BTFSC  xB9.0
185E:  MOVLW  01
1860:  MOVWF  01
1862:  RETURN 0
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_WriteBit 
....................  * PURPOSE:    Writes a single bit to the DS1820 device. 
....................  * 
....................  * INPUT:      bBit        value of bit to be written 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... void DS1820_WriteBit(bool bBit) 
.................... { 
....................    DS1820_DisableInterrupts(); 
....................     
....................    output_low(DS1820_DATAPIN); 
*
17E6:  BCF    F93.3
17E8:  BCF    F8A.3
....................    DS1820_DelayUs(DS1820_MSTR_BITSTART); 
17EA:  MOVLW  07
17EC:  MOVWF  00
17EE:  DECFSZ 00,F
17F0:  BRA    17EE
17F2:  BRA    17F4
....................  
....................    if (bBit != FALSE) 
17F4:  MOVF   xBB,F
17F6:  BZ    17FC
....................    { 
....................       output_high(DS1820_DATAPIN); 
17F8:  BCF    F93.3
17FA:  BSF    F8A.3
....................    } 
....................  
....................    DS1820_DelayUs(DS1820_BITWRITE_DLY); 
17FC:  MOVLW  64
17FE:  MOVWF  xBC
1800:  RCALL  1786
....................    output_high(DS1820_DATAPIN); 
1802:  BCF    F93.3
1804:  BSF    F8A.3
....................     
....................    DS1820_EnableInterrupts(); 
1806:  RETURN 0
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_ReadByte 
....................  * PURPOSE:    Reads a single byte from the DS1820 device. 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     - 
....................  * RETURN:     uint8          byte which has been read from the DS1820 
....................  ******************************************************************************/ 
.................... uint8 DS1820_ReadByte(void) 
*
19D4:  CLRF   xB8
.................... { 
....................    uint8 i; 
....................    uint8 value = 0; 
....................  
....................    for (i=0 ; i < 8; i++) 
19D6:  CLRF   xB7
19D8:  MOVF   xB7,W
19DA:  SUBLW  07
19DC:  BNC   1A04
....................    { 
....................       if ( DS1820_ReadBit() ) 
19DE:  RCALL  1838
19E0:  MOVF   01,F
19E2:  BZ    19FA
....................       { 
....................          value |= (1 << i); 
19E4:  MOVLW  01
19E6:  MOVWF  00
19E8:  MOVF   xB7,W
19EA:  MOVWF  01
19EC:  BZ    19F6
19EE:  BCF    FD8.0
19F0:  RLCF   00,F
19F2:  DECFSZ 01,F
19F4:  BRA    19EE
19F6:  MOVF   00,W
19F8:  IORWF  xB8,F
....................       } 
....................       DS1820_DelayUs(120); 
19FA:  MOVLW  78
19FC:  MOVWF  xBC
19FE:  RCALL  1786
1A00:  INCF   xB7,F
1A02:  BRA    19D8
....................    } 
....................    return(value); 
1A04:  MOVFF  B8,01
1A08:  GOTO   1A9E (RETURN)
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_WriteByte 
....................  * PURPOSE:    Writes a single byte to the DS1820 device. 
....................  * 
....................  * INPUT:      val_u8         byte to be written 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... void DS1820_WriteByte(uint8 val_u8) 
.................... { 
....................    uint8 i; 
....................    uint8 temp; 
....................  
....................    for (i=0; i < 8; i++)      /* writes byte, one bit at a time */ 
*
1808:  CLRF   xB9
180A:  MOVF   xB9,W
180C:  SUBLW  07
180E:  BNC   1830
....................    { 
....................       temp = val_u8 >> i;     /* shifts val right 'i' spaces */ 
1810:  MOVFF  B8,BA
1814:  MOVF   xB9,W
1816:  MOVWF  01
1818:  BZ    1822
181A:  BCF    FD8.0
181C:  RRCF   xBA,F
181E:  DECFSZ 01,F
1820:  BRA    181A
....................       temp &= 0x01;           /* copy that bit to temp */ 
1822:  MOVLW  01
1824:  ANDWF  xBA,F
....................       DS1820_WriteBit(temp);  /* write bit in temp into */ 
1826:  MOVFF  BA,BB
182A:  RCALL  17E6
182C:  INCF   xB9,F
182E:  BRA    180A
....................    } 
....................  
....................    DS1820_DelayUs(105); 
1830:  MOVLW  69
1832:  MOVWF  xBC
1834:  RCALL  1786
1836:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                             API Interface                                  */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_AddrDevice 
....................  * PURPOSE:    Addresses a single or all devices on the 1-wire bus. 
....................  * 
....................  * INPUT:      nAddrMethod       use DS1820_CMD_MATCHROM to select a single 
....................  *                               device or DS1820_CMD_SKIPROM to select all 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... void DS1820_AddrDevice(uint8 nAddrMethod) 
.................... { 
....................    uint8 i; 
....................     
....................    if (nAddrMethod == DS1820_CMD_MATCHROM) 
*
199A:  MOVF   xB5,W
199C:  SUBLW  55
199E:  BNZ   19CC
....................    { 
....................       DS1820_WriteByte(DS1820_CMD_MATCHROM);     /* address single devices on bus */ 
19A0:  MOVLW  55
19A2:  MOVWF  xB8
19A4:  RCALL  1808
....................       for (i = 0; i < DS1820_ADDR_LEN; i ++) 
19A6:  CLRF   xB6
19A8:  MOVF   xB6,W
19AA:  SUBLW  07
19AC:  BNC   19CA
....................       { 
....................          DS1820_WriteByte(nRomAddr_au8[i]); 
19AE:  CLRF   03
19B0:  MOVF   xB6,W
19B2:  ADDLW  1C
19B4:  MOVWF  FE9
19B6:  MOVLW  00
19B8:  ADDWFC 03,W
19BA:  MOVWF  FEA
19BC:  MOVFF  FEF,B7
19C0:  MOVFF  B7,B8
19C4:  RCALL  1808
19C6:  INCF   xB6,F
19C8:  BRA    19A8
....................       } 
....................    } 
19CA:  BRA    19D2
....................    else 
....................    { 
....................       DS1820_WriteByte(DS1820_CMD_SKIPROM);     /* address all devices on bus */ 
19CC:  MOVLW  CC
19CE:  MOVWF  xB8
19D0:  RCALL  1808
....................    } 
19D2:  RETURN 0
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_FindNextDevice 
....................  * PURPOSE:    Finds next device connected to the 1-wire bus. 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     nRomAddr_au8[]       ROM code of the next device 
....................  * RETURN:     bool                 TRUE if there are more devices on the 1-wire 
....................  *                                  bus, FALSE otherwise 
....................  ******************************************************************************/ 
.................... bool DS1820_FindNextDevice(void) 
*
1864:  MOVLW  01
1866:  MOVWF  xA9
1868:  MOVWF  xAA
186A:  CLRF   xAB
186C:  BCF    xAC.2
.................... { 
....................     uint8 state_u8; 
....................     uint8 byteidx_u8; 
....................     uint8 mask_u8 = 1; 
....................     uint8 bitpos_u8 = 1; 
....................     uint8 nDiscrepancyMarker_u8 = 0; 
....................     bool bit_b; 
....................     bool bStatus; 
....................     bool next_b = FALSE; 
....................  
....................     /* init ROM address */ 
....................     for (byteidx_u8=0; byteidx_u8 < 8; byteidx_u8 ++) 
186E:  CLRF   xA8
1870:  MOVF   xA8,W
1872:  SUBLW  07
1874:  BNC   188A
....................     { 
....................         nRomAddr_au8[byteidx_u8] = 0x00; 
1876:  CLRF   03
1878:  MOVF   xA8,W
187A:  ADDLW  1C
187C:  MOVWF  FE9
187E:  MOVLW  00
1880:  ADDWFC 03,W
1882:  MOVWF  FEA
1884:  CLRF   FEF
1886:  INCF   xA8,F
1888:  BRA    1870
....................     } 
....................  
....................     bStatus = DS1820_Reset();        /* reset the 1-wire */ 
188A:  RCALL  17A6
188C:  BCF    xAC.1
188E:  BTFSC  01.0
1890:  BSF    xAC.1
....................  
....................     if (bStatus || bDoneFlag)        /* no device found */ 
1892:  BTFSC  xAC.1
1894:  BRA    189A
1896:  BTFSS  1A.0
1898:  BRA    18A2
....................     { 
....................         nLastDiscrepancy_u8 = 0;     /* reset the search */ 
189A:  CLRF   1B
....................         return FALSE; 
189C:  MOVLW  00
189E:  MOVWF  01
18A0:  BRA    198C
....................     } 
....................  
....................     /* send search rom command */ 
....................     DS1820_WriteByte(DS1820_CMD_SEARCHROM); 
18A2:  MOVLW  F0
18A4:  MOVWF  xB8
18A6:  RCALL  1808
....................  
....................     byteidx_u8 = 0; 
18A8:  CLRF   xA8
....................     do 
....................     { 
....................         state_u8 = 0; 
18AA:  CLRF   xA7
....................  
....................         /* read bit */ 
....................         if ( DS1820_ReadBit() != 0 ) 
18AC:  RCALL  1838
18AE:  MOVF   01,F
18B0:  BZ    18B6
....................         { 
....................             state_u8 = 2; 
18B2:  MOVLW  02
18B4:  MOVWF  xA7
....................         } 
....................         DS1820_DelayUs(120); 
18B6:  MOVLW  78
18B8:  MOVWF  xBC
18BA:  RCALL  1786
....................  
....................         /* read bit complement */ 
....................         if ( DS1820_ReadBit() != 0 ) 
18BC:  RCALL  1838
18BE:  MOVF   01,F
18C0:  BZ    18C4
....................         { 
....................             state_u8 |= 1; 
18C2:  BSF    xA7.0
....................         } 
....................         DS1820_DelayUs(120); 
18C4:  MOVLW  78
18C6:  MOVWF  xBC
18C8:  RCALL  1786
....................  
....................         /* description for values of state_u8: */ 
....................         /* 00    There are devices connected to the bus which have conflicting */ 
....................         /*       bits in the current ROM code bit position. */ 
....................         /* 01    All devices connected to the bus have a 0 in this bit position. */ 
....................         /* 10    All devices connected to the bus have a 1 in this bit position. */ 
....................         /* 11    There are no devices connected to the 1-wire bus. */ 
....................  
....................         /* if there are no devices on the bus */ 
....................         if (state_u8 == 3) 
18CA:  MOVF   xA7,W
18CC:  SUBLW  03
18CE:  BNZ   18D4
....................         { 
....................             break; 
18D0:  BRA    196C
....................         } 
18D2:  BRA    1966
....................         else 
....................         { 
....................             /* devices have the same logical value at this position */ 
....................             if (state_u8 > 0) 
18D4:  MOVF   xA7,F
18D6:  BZ    18E8
....................             { 
....................                 /* get bit value */ 
....................                 bit_b = (bool)(state_u8 >> 1); 
18D8:  BCF    xAC.0
18DA:  BCF    FD8.0
18DC:  RRCF   xA7,W
18DE:  MOVWF  01
18E0:  BTFSS  FE8.0
18E2:  BRA    18E6
18E4:  BSF    xAC.0
....................             } 
18E6:  BRA    191A
....................             /* devices have confilcting bits in the current ROM code */ 
....................             else 
....................             { 
....................                 /* if there was a conflict on the last iteration */ 
....................                 if (bitpos_u8 < nLastDiscrepancy_u8) 
18E8:  MOVF   1B,W
18EA:  SUBWF  xAA,W
18EC:  BC    1908
....................                 { 
....................                     /* take same bit as in last iteration */ 
....................                     bit_b = ( (nRomAddr_au8[byteidx_u8] & mask_u8) > 0 ); 
18EE:  BCF    xAC.0
18F0:  CLRF   03
18F2:  MOVF   xA8,W
18F4:  ADDLW  1C
18F6:  MOVWF  FE9
18F8:  MOVLW  00
18FA:  ADDWFC 03,W
18FC:  MOVWF  FEA
18FE:  MOVF   FEF,W
1900:  ANDWF  xA9,W
1902:  BZ    1906
1904:  BSF    xAC.0
....................                 } 
1906:  BRA    1912
....................                 else 
....................                 { 
....................                     bit_b = (bitpos_u8 == nLastDiscrepancy_u8); 
1908:  BCF    xAC.0
190A:  MOVF   1B,W
190C:  SUBWF  xAA,W
190E:  BNZ   1912
1910:  BSF    xAC.0
....................                 } 
....................  
....................                 if (bit_b == 0) 
1912:  BTFSC  xAC.0
1914:  BRA    191A
....................                 { 
....................                     nDiscrepancyMarker_u8 = bitpos_u8; 
1916:  MOVFF  AA,AB
....................                 } 
....................             } 
....................  
....................             /* store bit in ROM address */ 
....................            if (bit_b != 0) 
191A:  BTFSS  xAC.0
191C:  BRA    1934
....................            { 
....................                nRomAddr_au8[byteidx_u8] |= mask_u8; 
191E:  CLRF   03
1920:  MOVF   xA8,W
1922:  ADDLW  1C
1924:  MOVWF  FE9
1926:  MOVLW  00
1928:  ADDWFC 03,W
192A:  MOVWF  FEA
192C:  MOVF   FEF,W
192E:  IORWF  xA9,W
1930:  MOVWF  FEF
....................            } 
1932:  BRA    194A
....................            else 
....................            { 
....................                nRomAddr_au8[byteidx_u8] &= ~mask_u8; 
1934:  CLRF   03
1936:  MOVF   xA8,W
1938:  ADDLW  1C
193A:  MOVWF  FE9
193C:  MOVLW  00
193E:  ADDWFC 03,W
1940:  MOVWF  FEA
1942:  MOVF   xA9,W
1944:  XORLW  FF
1946:  ANDWF  FEF,W
1948:  MOVWF  FEF
....................            } 
....................  
....................            DS1820_WriteBit(bit_b); 
194A:  MOVLW  00
194C:  BTFSC  xAC.0
194E:  MOVLW  01
1950:  MOVWF  xAD
1952:  MOVWF  xBB
1954:  RCALL  17E6
....................  
....................            /* increment bit position */ 
....................            bitpos_u8 ++; 
1956:  INCF   xAA,F
....................  
....................            /* calculate next mask value */ 
....................            mask_u8 = mask_u8 << 1; 
1958:  BCF    FD8.0
195A:  RLCF   xA9,F
....................  
....................            /* check if this byte has finished */ 
....................            if (mask_u8 == 0) 
195C:  MOVF   xA9,F
195E:  BNZ   1966
....................            { 
....................                byteidx_u8 ++;  /* advance to next byte of ROM mask */ 
1960:  INCF   xA8,F
....................                mask_u8 = 1;    /* update mask */ 
1962:  MOVLW  01
1964:  MOVWF  xA9
....................            } 
....................         } 
....................     } while (byteidx_u8 < DS1820_ADDR_LEN); 
1966:  MOVF   xA8,W
1968:  SUBLW  07
196A:  BC    18AA
....................  
....................  
....................     /* if search was unsuccessful then */ 
....................     if (bitpos_u8 < 65) 
196C:  MOVF   xAA,W
196E:  SUBLW  40
1970:  BNC   1976
....................     { 
....................         /* reset the last discrepancy to 0 */ 
....................         nLastDiscrepancy_u8 = 0; 
1972:  CLRF   1B
....................     } 
1974:  BRA    1984
....................     else 
....................     { 
....................         /* search was successful */ 
....................         nLastDiscrepancy_u8 = nDiscrepancyMarker_u8; 
1976:  MOVFF  AB,1B
....................         bDoneFlag = (nLastDiscrepancy_u8 == 0); 
197A:  BCF    1A.0
197C:  MOVF   1B,F
197E:  BNZ   1982
1980:  BSF    1A.0
....................  
....................         /* indicates search is not complete yet, more parts remain */ 
....................         next_b = TRUE; 
1982:  BSF    xAC.2
....................     } 
....................  
....................     return next_b; 
1984:  MOVLW  00
1986:  BTFSC  xAC.2
1988:  MOVLW  01
198A:  MOVWF  01
198C:  RETURN 0
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_FindFirstDevice 
....................  * PURPOSE:    Starts the device search on the 1-wire bus. 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     nRomAddr_au8[]       ROM code of the first device 
....................  * RETURN:     bool                 TRUE if there are more devices on the 1-wire 
....................  *                                  bus, FALSE otherwise 
....................  ******************************************************************************/ 
.................... bool DS1820_FindFirstDevice(void) 
.................... { 
....................     nLastDiscrepancy_u8 = 0; 
198E:  CLRF   1B
....................     bDoneFlag = FALSE; 
1990:  BCF    1A.0
....................  
....................     return ( DS1820_FindNextDevice() ); 
1992:  RCALL  1864
1994:  MOVF   01,W
1996:  GOTO   225E (RETURN)
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_WriteEEPROM 
....................  * PURPOSE:    Writes to the DS1820 EEPROM memory (2 bytes available). 
....................  * 
....................  * INPUT:      nTHigh         high byte of EEPROM 
....................  *             nTLow          low byte of EEPROM 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... void DS1820_WriteEEPROM(uint8 nTHigh, uint8 nTLow) 
.................... { 
....................     /* --- write to scratchpad ----------------------------------------------- */ 
....................     DS1820_Reset(); 
....................     DS1820_AddrDevice(DS1820_CMD_MATCHROM); 
....................     DS1820_WriteByte(DS1820_CMD_WRITESCRPAD); /* start conversion */ 
....................     DS1820_WriteByte(nTHigh); 
....................     DS1820_WriteByte(nTLow); 
....................  
....................     DS1820_DelayUs(10); 
....................  
....................     DS1820_Reset(); 
....................     DS1820_AddrDevice(DS1820_CMD_MATCHROM); 
....................     DS1820_WriteByte(DS1820_CMD_COPYSCRPAD); /* start conversion */ 
....................  
....................     delay_ms(10); 
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_GetTempRaw 
....................  * PURPOSE:    Get temperature raw value from single DS1820 device. 
....................  * 
....................  *             Scratchpad Memory Layout 
....................  *             Byte  Register 
....................  *             0     Temperature_LSB 
....................  *             1     Temperature_MSB 
....................  *             2     Temp Alarm High / User Byte 1 
....................  *             3     Temp Alarm Low / User Byte 2 
....................  *             4     Reserved 
....................  *             5     Reserved 
....................  *             6     Count_Remain 
....................  *             7     Count_per_C 
....................  *             8     CRC 
....................  * 
....................  *             Temperature calculation for DS18S20 (Family Code 0x10): 
....................  *             ======================================================= 
....................  *                                             (Count_per_C - Count_Remain) 
....................  *             Temperature = temp_raw - 0.25 + ---------------------------- 
....................  *                                                     Count_per_C 
....................  * 
....................  *             Where temp_raw is the value from the temp_MSB and temp_LSB with 
....................  *             the least significant bit removed (the 0.5C bit). 
....................  * 
....................  * 
....................  *             Temperature calculation for DS18B20 (Family Code 0x28): 
....................  *             ======================================================= 
....................  *                      bit7   bit6   bit5   bit4   bit3   bit2   bit1   bit0 
....................  *             LSB      2^3    2^2    2^1    2^0    2^-1   2^-2   2^-3   2^-4 
....................  *                      bit15  bit14  bit13  bit12  bit3   bit2   bit1   bit0 
....................  *             MSB      S      S      S      S      S      2^6    2^5    2^4 
....................  * 
....................  *             The temperature data is stored as a 16-bit sign-extended twos 
....................  *             complement number in the temperature register. The sign bits (S) 
....................  *             indicate if the temperature is positive or negative: for 
....................  *             positive numbers S = 0 and for negative numbers S = 1. 
....................  * 
....................  * RETURN:     sint16         raw temperature value with a resolution 
....................  *                            of 1/256°C 
....................  ******************************************************************************/ 
.................... sint16 DS1820_GetTempRaw(void) 
.................... { 
....................     uint8 i; 
....................     uint16 temp_u16; 
....................     uint16 highres_u16; 
....................     uint8 scrpad[DS1820_SCRPADMEM_LEN]; 
....................  
....................     /* --- start temperature conversion -------------------------------------- */ 
....................     DS1820_Reset(); 
*
1A50:  RCALL  17A6
....................     DS1820_AddrDevice(DS1820_CMD_MATCHROM);     /* address the device */ 
1A52:  MOVLW  55
1A54:  MOVWF  xB5
1A56:  RCALL  199A
....................     output_high(DS1820_DATAPIN); 
1A58:  BCF    F93.3
1A5A:  BSF    F8A.3
....................     DS1820_WriteByte(DS1820_CMD_CONVERTTEMP);   /* start conversion */ 
1A5C:  MOVLW  44
1A5E:  MOVWF  xB8
1A60:  RCALL  1808
....................     //DS1820_DelayMs(DS1820_TEMPCONVERT_DLY);   /* wait for temperature conversion */ 
....................     DS1820_DelayMs(750); 
1A62:  MOVLW  03
1A64:  MOVWF  xB5
1A66:  MOVLW  FA
1A68:  MOVWF  xB6
1A6A:  CALL   1014
1A6E:  DECFSZ xB5,F
1A70:  BRA    1A66
....................  
....................  
....................     /* --- read sratchpad ---------------------------------------------------- */ 
....................     DS1820_Reset(); 
1A72:  RCALL  17A6
....................     DS1820_AddrDevice(DS1820_CMD_MATCHROM);   /* address the device */ 
1A74:  MOVLW  55
1A76:  MOVWF  xB5
1A78:  RCALL  199A
....................     DS1820_WriteByte(DS1820_CMD_READSCRPAD);  /* read scratch pad */ 
1A7A:  MOVLW  BE
1A7C:  MOVWF  xB8
1A7E:  RCALL  1808
....................  
....................     /* read scratch pad data */ 
....................     for (i=0; i < DS1820_SCRPADMEM_LEN; i++) 
1A80:  CLRF   xA7
1A82:  MOVF   xA7,W
1A84:  SUBLW  08
1A86:  BNC   1AAE
....................     { 
....................         scrpad[i] = DS1820_ReadByte(); 
1A88:  CLRF   03
1A8A:  MOVF   xA7,W
1A8C:  ADDLW  AC
1A8E:  MOVWF  01
1A90:  MOVLW  00
1A92:  ADDWFC 03,F
1A94:  MOVFF  01,B5
1A98:  MOVFF  03,B6
1A9C:  BRA    19D4
1A9E:  MOVFF  B6,FEA
1AA2:  MOVFF  B5,FE9
1AA6:  MOVFF  01,FEF
1AAA:  INCF   xA7,F
1AAC:  BRA    1A82
....................     } 
....................  
....................  
....................     /* --- calculate temperature --------------------------------------------- */ 
....................     /* Formular for temperature calculation: */ 
....................     /* Temp = Temp_read - 0.25 + ((Count_per_C - Count_Remain)/Count_per_C) */ 
....................  
....................     /* get raw value of temperature (0.5°C resolution) */ 
....................     temp_u16 = 0; 
1AAE:  CLRF   xA9
1AB0:  CLRF   xA8
....................     temp_u16 = (uint16)((uint16)scrpad[DS1820_REG_TEMPMSB] << 8); 
1AB2:  MOVFF  AD,A9
1AB6:  CLRF   xA8
....................     temp_u16 |= (uint16)(scrpad[DS1820_REG_TEMPLSB]); 
1AB8:  CLRF   03
1ABA:  MOVF   xAC,W
1ABC:  IORWF  xA8,F
1ABE:  MOVF   03,W
1AC0:  IORWF  xA9,F
....................  
....................     if (nRomAddr_au8[0] == DS1820_FAMILY_CODE_DS18S20) 
1AC2:  MOVF   1C,W
1AC4:  SUBLW  10
1AC6:  BNZ   1B1C
....................     { 
....................         /* get temperature value in 1°C resolution */ 
....................         temp_u16 >>= 1; 
1AC8:  BCF    FD8.0
1ACA:  RRCF   xA9,F
1ACC:  RRCF   xA8,F
....................      
....................         /* temperature resolution is TEMP_RES (0x100), so 1°C equals 0x100 */ 
....................         /* => convert to temperature to 1/256°C resolution */ 
....................         temp_u16 = ((uint16)temp_u16 << 8); 
1ACE:  MOVFF  A8,A9
1AD2:  CLRF   xA8
....................      
....................         /* now substract 0.25°C */ 
....................         temp_u16 -= ((uint16)TEMP_RES >> 2); 
1AD4:  MOVLW  40
1AD6:  SUBWF  xA8,F
1AD8:  MOVLW  00
1ADA:  SUBWFB xA9,F
....................      
....................         /* now calculate high resolution */ 
....................         highres_u16 = scrpad[DS1820_REG_CNTPERSEC] - scrpad[DS1820_REG_CNTREMAIN]; 
1ADC:  MOVF   xB2,W
1ADE:  SUBWF  xB3,W
1AE0:  MOVWF  xAA
1AE2:  CLRF   xAB
....................         highres_u16 = ((uint16)highres_u16 << 8); 
1AE4:  MOVFF  AA,AB
1AE8:  CLRF   xAA
....................         if (scrpad[DS1820_REG_CNTPERSEC]) 
1AEA:  MOVF   xB3,F
1AEC:  BZ    1B12
....................         { 
....................             highres_u16 = highres_u16 / (uint16)scrpad[DS1820_REG_CNTPERSEC]; 
1AEE:  CLRF   03
1AF0:  MOVFF  B3,B5
1AF4:  MOVFF  03,B6
1AF8:  MOVFF  AB,B8
1AFC:  MOVFF  AA,B7
1B00:  MOVFF  03,BA
1B04:  MOVFF  B3,B9
1B08:  BRA    1A0C
1B0A:  MOVFF  02,AB
1B0E:  MOVFF  01,AA
....................         } 
....................      
....................         /* now calculate result */ 
....................         highres_u16 = highres_u16 + temp_u16; 
1B12:  MOVF   xA8,W
1B14:  ADDWF  xAA,F
1B16:  MOVF   xA9,W
1B18:  ADDWFC xAB,F
....................     } 
1B1A:  BRA    1B38
....................     else 
....................     { 
....................         /* 12 bit temperature value has 0.0625°C resolution */ 
....................         /* shift left by 4 to get 1/256°C resolution */ 
....................         highres_u16 = temp_u16; 
1B1C:  MOVFF  A9,AB
1B20:  MOVFF  A8,AA
....................         highres_u16 <<= 4; 
1B24:  RLCF   xAA,F
1B26:  RLCF   xAB,F
1B28:  RLCF   xAA,F
1B2A:  RLCF   xAB,F
1B2C:  RLCF   xAA,F
1B2E:  RLCF   xAB,F
1B30:  RLCF   xAA,F
1B32:  RLCF   xAB,F
1B34:  MOVLW  F0
1B36:  ANDWF  xAA,F
....................     } 
....................  
....................     return (highres_u16); 
1B38:  MOVFF  AA,01
1B3C:  MOVFF  AB,02
1B40:  RETURN 0
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_GetTempFloat 
....................  * PURPOSE:    Converts internal temperature value to string (physical value). 
....................  * 
....................  * INPUT:      none 
....................  * OUTPUT:     none 
....................  * RETURN:     float          temperature value with as float value 
....................  ******************************************************************************/ 
.................... float DS1820_GetTempFloat(void) 
.................... { 
....................     return ((float)DS1820_GetTempRaw() / (float)TEMP_RES); 
*
1EAE:  RCALL  1A50
1EB0:  MOVFF  02,A8
1EB4:  MOVFF  01,A7
1EB8:  BRA    1D1A
1EBA:  MOVFF  03,AA
1EBE:  MOVFF  02,A9
1EC2:  MOVFF  01,A8
1EC6:  MOVFF  00,A7
1ECA:  MOVFF  03,AE
1ECE:  MOVFF  02,AD
1ED2:  MOVFF  01,AC
1ED6:  MOVFF  00,AB
1EDA:  CLRF   xB2
1EDC:  CLRF   xB1
1EDE:  CLRF   xB0
1EE0:  MOVLW  87
1EE2:  MOVWF  xAF
1EE4:  BRA    1D52
1EE6:  GOTO   2280 (RETURN)
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_GetTempString 
....................  * PURPOSE:    Converts internal temperature value to string (physical value). 
....................  * 
....................  * INPUT:      tRaw_s16       internal temperature value 
....................  * OUTPUT:     strTemp_pc     user string buffer to write temperature value 
....................  * RETURN:     sint16         temperature value with an internal resolution 
....................  *                            of TEMP_RES 
....................  ******************************************************************************/ 
.................... void DS1820_GetTempString(sint16 tRaw_s16, char *strTemp_pc) 
.................... { 
....................     sint16 tPhyLow_s16; 
....................     sint8 tPhy_s8; 
....................  
....................     /* convert from raw value (1/256°C resolution) to physical value */ 
....................     tPhy_s8 = (sint8)(tRaw_s16/TEMP_RES); 
*
1CBE:  MOVF   xA8,W
1CC0:  MOVWF  xAD
....................  
....................     /* convert digits from raw value (1/256°C resolution) to physical value */ 
....................     /*tPhyLow_u16 = tInt_s16 % TEMP_RES;*/ 
....................     tPhyLow_s16 = tRaw_s16 & 0xFF;      /* this operation is the same as */ 
1CC2:  MOVFF  A7,AB
1CC6:  CLRF   xAC
1CC8:  CLRF   19
1CCA:  BTFSC  FF2.7
1CCC:  BSF    19.7
1CCE:  BCF    FF2.7
....................                                         /* but saves flash memory tInt_s16 % TEMP_RES */ 
....................     tPhyLow_s16 = tPhyLow_s16 * 100; 
1CD0:  MOVFF  AC,DC
1CD4:  MOVFF  AB,DB
1CD8:  CLRF   xDE
1CDA:  MOVLW  64
1CDC:  MOVWF  xDD
1CDE:  CALL   02BC
1CE2:  BTFSC  19.7
1CE4:  BSF    FF2.7
1CE6:  MOVFF  02,AC
1CEA:  MOVFF  01,AB
....................     tPhyLow_s16 = (uint16)tPhyLow_s16 / TEMP_RES; 
1CEE:  MOVFF  AC,AB
1CF2:  CLRF   xAC
....................  
....................     /* write physical temperature value to string */ 
....................     sprintf(strTemp_pc, "%d.%02d", tPhy_s8, (sint8)tPhyLow_s16); 
1CF4:  MOVFF  AA,25
1CF8:  MOVFF  A9,24
1CFC:  MOVFF  AD,AE
1D00:  MOVLW  18
1D02:  MOVWF  xAF
1D04:  BRA    1B5E
1D06:  MOVLW  2E
1D08:  MOVWF  xB4
1D0A:  RCALL  1B42
1D0C:  MOVFF  AB,AE
1D10:  MOVLW  01
1D12:  MOVWF  xAF
1D14:  BRA    1C0E
1D16:  GOTO   227E (RETURN)
.................... } 
....................  
.................... #endif /* _DS1820_H */ 
....................  
....................  
....................  
.................... #include "drv\ds1307.c" 
.................... #define DS1307_SDA  PIN_B0 
.................... #define DS1307_SCL  PIN_B1 
.................... #use i2c(master, sda=DS1307_SDA, scl=DS1307_SCL) 
*
133A:  MOVLW  08
133C:  MOVWF  01
133E:  MOVLW  11
1340:  MOVWF  00
1342:  DECFSZ 00,F
1344:  BRA    1342
1346:  BCF    F8A.1
1348:  BCF    F93.1
134A:  MOVLW  11
134C:  MOVWF  00
134E:  DECFSZ 00,F
1350:  BRA    134E
1352:  RLCF   x9E,F
1354:  BCF    F8A.0
1356:  BTFSC  FD8.0
1358:  BSF    F93.0
135A:  BTFSS  FD8.0
135C:  BCF    F93.0
135E:  BSF    F93.1
1360:  BTFSS  F81.1
1362:  BRA    1360
1364:  DECFSZ 01,F
1366:  BRA    133E
1368:  MOVLW  11
136A:  MOVWF  00
136C:  DECFSZ 00,F
136E:  BRA    136C
1370:  BCF    F8A.1
1372:  BCF    F93.1
1374:  NOP   
1376:  BSF    F93.0
1378:  MOVLW  11
137A:  MOVWF  00
137C:  DECFSZ 00,F
137E:  BRA    137C
1380:  MOVLW  11
1382:  MOVWF  00
1384:  DECFSZ 00,F
1386:  BRA    1384
1388:  BSF    F93.1
138A:  BTFSS  F81.1
138C:  BRA    138A
138E:  CLRF   01
1390:  MOVLW  11
1392:  MOVWF  00
1394:  DECFSZ 00,F
1396:  BRA    1394
1398:  BTFSC  F81.0
139A:  BSF    01.0
139C:  BCF    F8A.1
139E:  BCF    F93.1
13A0:  BCF    F8A.0
13A2:  BCF    F93.0
13A4:  RETURN 0
*
1550:  MOVLW  08
1552:  MOVWF  x9B
1554:  MOVFF  00,9C
1558:  BSF    F93.0
155A:  MOVLW  11
155C:  MOVWF  00
155E:  DECFSZ 00,F
1560:  BRA    155E
1562:  BSF    F93.1
1564:  BTFSS  F81.1
1566:  BRA    1564
1568:  BTFSC  F81.0
156A:  BSF    FD8.0
156C:  BTFSS  F81.0
156E:  BCF    FD8.0
1570:  RLCF   01,F
1572:  MOVLW  11
1574:  MOVWF  00
1576:  DECFSZ 00,F
1578:  BRA    1576
157A:  BCF    F93.1
157C:  BCF    F8A.1
157E:  DECFSZ x9B,F
1580:  BRA    1558
1582:  BSF    F93.0
1584:  MOVLW  11
1586:  MOVWF  00
1588:  DECFSZ 00,F
158A:  BRA    1588
158C:  BCF    F8A.0
158E:  MOVF   x9C,W
1590:  BTFSS  FD8.2
1592:  BCF    F93.0
1594:  NOP   
1596:  BSF    F93.1
1598:  BTFSS  F81.1
159A:  BRA    1598
159C:  MOVLW  11
159E:  MOVWF  00
15A0:  DECFSZ 00,F
15A2:  BRA    15A0
15A4:  BCF    F8A.1
15A6:  BCF    F93.1
15A8:  MOVLW  11
15AA:  MOVWF  00
15AC:  DECFSZ 00,F
15AE:  BRA    15AC
15B0:  BCF    F8A.0
15B2:  BCF    F93.0
15B4:  GOTO   161E (RETURN)
....................  
.................... //========================== 
.................... // initial DS1307 
.................... //========================== 
.................... void init_DS1307() 
.................... { 
....................    output_float(DS1307_SCL); 
....................    output_float(DS1307_SDA); 
.................... } 
.................... //========================== 
.................... // write data one byte to 
.................... // DS1307 
.................... //========================== 
.................... void write_DS1307(byte address, BYTE data) 
*
13A6:  CLRF   x9D
.................... { 
....................    short int status; 
....................     int x = 0; 
....................    i2c_start(); 
13A8:  BSF    F93.0
13AA:  MOVLW  11
13AC:  MOVWF  00
13AE:  DECFSZ 00,F
13B0:  BRA    13AE
13B2:  BSF    F93.1
13B4:  MOVLW  11
13B6:  MOVWF  00
13B8:  DECFSZ 00,F
13BA:  BRA    13B8
13BC:  BCF    F8A.0
13BE:  BCF    F93.0
13C0:  MOVLW  11
13C2:  MOVWF  00
13C4:  DECFSZ 00,F
13C6:  BRA    13C4
13C8:  BCF    F8A.1
13CA:  BCF    F93.1
....................    i2c_write(0xd0); 
13CC:  MOVLW  D0
13CE:  MOVWF  x9E
13D0:  RCALL  133A
....................    i2c_write(address); 
13D2:  MOVFF  9A,9E
13D6:  RCALL  133A
....................    i2c_write(data); 
13D8:  MOVFF  9B,9E
13DC:  RCALL  133A
....................    i2c_stop(); 
13DE:  BCF    F93.0
13E0:  NOP   
13E2:  BSF    F93.1
13E4:  BTFSS  F81.1
13E6:  BRA    13E4
13E8:  MOVLW  11
13EA:  MOVWF  00
13EC:  DECFSZ 00,F
13EE:  BRA    13EC
13F0:  BRA    13F2
13F2:  NOP   
13F4:  BSF    F93.0
13F6:  MOVLW  11
13F8:  MOVWF  00
13FA:  DECFSZ 00,F
13FC:  BRA    13FA
....................    i2c_start(); 
13FE:  BSF    F93.0
1400:  MOVLW  11
1402:  MOVWF  00
1404:  DECFSZ 00,F
1406:  BRA    1404
1408:  BSF    F93.1
140A:  MOVLW  11
140C:  MOVWF  00
140E:  DECFSZ 00,F
1410:  BRA    140E
1412:  BCF    F8A.0
1414:  BCF    F93.0
1416:  MOVLW  11
1418:  MOVWF  00
141A:  DECFSZ 00,F
141C:  BRA    141A
141E:  BCF    F8A.1
1420:  BCF    F93.1
....................    status=i2c_write(0xd0); 
1422:  MOVLW  D0
1424:  MOVWF  x9E
1426:  RCALL  133A
1428:  MOVF   01,W
142A:  BCF    x9C.0
142C:  BTFSC  01.0
142E:  BSF    x9C.0
....................    while(status==1 || x<5) 
1430:  BTFSC  x9C.0
1432:  BRA    143A
1434:  MOVF   x9D,W
1436:  SUBLW  04
1438:  BNC   1474
....................    { 
....................       i2c_start(); 
143A:  BSF    F93.0
143C:  MOVLW  11
143E:  MOVWF  00
1440:  DECFSZ 00,F
1442:  BRA    1440
1444:  BSF    F93.1
1446:  MOVLW  11
1448:  MOVWF  00
144A:  DECFSZ 00,F
144C:  BRA    144A
144E:  BTFSS  F81.1
1450:  BRA    144E
1452:  BCF    F8A.0
1454:  BCF    F93.0
1456:  MOVLW  11
1458:  MOVWF  00
145A:  DECFSZ 00,F
145C:  BRA    145A
145E:  BCF    F8A.1
1460:  BCF    F93.1
....................       status=i2c_write(0xd0); 
1462:  MOVLW  D0
1464:  MOVWF  x9E
1466:  RCALL  133A
1468:  MOVF   01,W
146A:  BCF    x9C.0
146C:  BTFSC  01.0
146E:  BSF    x9C.0
....................       x++; 
1470:  INCF   x9D,F
1472:  BRA    1430
....................    } 
1474:  RETURN 0
.................... } 
.................... //========================== 
.................... // read data one byte from DS1307 
.................... //========================== 
.................... BYTE read_DS1307(byte address) 
.................... { 
....................    BYTE data; 
....................    i2c_start(); 
*
15B8:  BSF    F93.0
15BA:  MOVLW  11
15BC:  MOVWF  00
15BE:  DECFSZ 00,F
15C0:  BRA    15BE
15C2:  BSF    F93.1
15C4:  MOVLW  11
15C6:  MOVWF  00
15C8:  DECFSZ 00,F
15CA:  BRA    15C8
15CC:  BTFSS  F81.1
15CE:  BRA    15CC
15D0:  BCF    F8A.0
15D2:  BCF    F93.0
15D4:  MOVLW  11
15D6:  MOVWF  00
15D8:  DECFSZ 00,F
15DA:  BRA    15D8
15DC:  BCF    F8A.1
15DE:  BCF    F93.1
....................    i2c_write(0xd0); 
15E0:  MOVLW  D0
15E2:  MOVWF  x9E
15E4:  RCALL  133A
....................    i2c_write(address); 
15E6:  MOVFF  98,9E
15EA:  RCALL  133A
....................    i2c_start(); 
15EC:  BSF    F93.0
15EE:  MOVLW  11
15F0:  MOVWF  00
15F2:  DECFSZ 00,F
15F4:  BRA    15F2
15F6:  BSF    F93.1
15F8:  MOVLW  11
15FA:  MOVWF  00
15FC:  DECFSZ 00,F
15FE:  BRA    15FC
1600:  BTFSS  F81.1
1602:  BRA    1600
1604:  BCF    F8A.0
1606:  BCF    F93.0
1608:  MOVLW  11
160A:  MOVWF  00
160C:  DECFSZ 00,F
160E:  BRA    160C
1610:  BCF    F8A.1
1612:  BCF    F93.1
....................    i2c_write(0xd1); 
1614:  MOVLW  D1
1616:  MOVWF  x9E
1618:  RCALL  133A
....................    data=i2c_read(0); 
161A:  CLRF   00
161C:  BRA    1550
161E:  MOVFF  01,99
....................    i2c_stop(); 
1622:  BCF    F93.0
1624:  NOP   
1626:  BSF    F93.1
1628:  BTFSS  F81.1
162A:  BRA    1628
162C:  MOVLW  11
162E:  MOVWF  00
1630:  DECFSZ 00,F
1632:  BRA    1630
1634:  BRA    1636
1636:  NOP   
1638:  BSF    F93.0
163A:  MOVLW  11
163C:  MOVWF  00
163E:  DECFSZ 00,F
1640:  BRA    163E
....................    return(data); 
1642:  MOVFF  99,01
1646:  RETURN 0
.................... } 
....................  
.................... #include "conversion.c" 
.................... // Convert normal decimal numbers to binary coded decimal 
.................... byte decToBcd(byte val) 
.................... { 
....................   return ( (val/10*16) + (val%10) ); 
*
1316:  MOVFF  99,B4
131A:  MOVLW  0A
131C:  MOVWF  xB5
131E:  RCALL  12EE
1320:  MOVF   01,W
1322:  MULLW  10
1324:  MOVFF  FF3,9A
1328:  MOVFF  99,B4
132C:  MOVLW  0A
132E:  MOVWF  xB5
1330:  RCALL  12EE
1332:  MOVF   00,W
1334:  ADDWF  x9A,W
1336:  MOVWF  01
1338:  RETURN 0
.................... } 
....................  
.................... // Convert binary coded decimal to normal decimal numbers 
.................... byte bcdToDec(byte val) 
.................... { 
....................   return ( (val/16*10) + (val%16) ); 
*
1648:  SWAPF  x99,W
164A:  MOVWF  00
164C:  MOVLW  0F
164E:  ANDWF  00,F
1650:  MOVF   00,W
1652:  MULLW  0A
1654:  MOVFF  FF3,9A
1658:  MOVF   x99,W
165A:  ANDLW  0F
165C:  ADDWF  x9A,W
165E:  MOVWF  01
1660:  RETURN 0
.................... } 
....................  
....................  
.................... //#include "ds1820.c" 
.................... //lsusb daje vid:pid 
.................... //#define  USB_CONFIG_VID     0x10c4 
.................... #define  USB_CONFIG_VID     0x0403 
.................... //#define  USB_CONFIG_PID     0xea60 
.................... #define  USB_CONFIG_PID     0x6001 
.................... #define  USB_CONFIG_BUS_POWER 300   //100mA  (range is 0..500) 
....................  
.................... #include <usb_cdc.h>  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    //// 
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////     'ptr' needs to be smaller than the transmit buffer.         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    //// 
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////     'len' needs to be smaller than the transmit buffer.         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns the number of bytes available      //// 
.................... ////     in the TX buffer for storing characters.  If this returns   //// 
.................... ////     0 then the buffer is full and waiting for the host (PC)     //// 
.................... ////     to read the buffer.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   //// 
.................... ////     empty and fully flushed/transmitted to host (PC).           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          //// 
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   //// 
.................... ////       ring, break and more.  See the documentation above        //// 
.................... ////       usb_cdc_serial_state() for more information, including    //// 
.................... ////       format of state structure.                                //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  //// 
.................... //// be called when there is incoming CDC (virtual com port) data.   //// 
.................... //// This is useful if you want to update legacy RS232 code that     //// 
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    //// 
.................... //// However, see the INTERRUPT LIMITATIONS section below.           //// 
.................... ////                                                                 //// 
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    //// 
.................... ////  to flush the data as soon as possible.  However at times       //// 
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   //// 
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         //// 
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     //// 
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       //// 
.................... ////  also attempt to flush the packet on each call to usb_task().   //// 
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     //// 
.................... ////  if you have a main loop that periodically calls usb_task().    //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// Encapsuated Messages: (USB_CDC_USE_ENCAPSULATED)                //// 
.................... //// -------------------------------------------------------------   //// 
.................... ////                                                                 //// 
.................... //// If USB_CDC_USE_ENCAPSULATED is defined, then the user must      //// 
.................... //// provide the following callbacks in their application to provide //// 
.................... //// encapsuated message support (SendEncapsulatedCommand and        //// 
.................... ////  GetEncapsulatedResponse):                                      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_SendEncapsulatedCommand(byte *ptr, unsigned int16 num)  //// 
.................... ////     PIC receives encapsulated command from host (PC), 'num'     //// 
.................... ////     bytes of message stored in 'ptr'.                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_GetEncapsulatedResponse(byte *ptr, unsigned int16 num)  //// 
.................... ////     Host (PC) is asking for 'num' bytes response from the PIC,  //// 
.................... ////     PIC should store up to 'num' bytes to 'ptr' as the          //// 
.................... ////     response.                                                   //// 
.................... ////                                                                 //// 
.................... //// Due to the design of the USB stack, all encapsulated messages   //// 
.................... //// must be smaller than one endpoint 0 packet.  They cannot be     //// 
.................... //// equal in size or larger than the endpoint 0 size.  See          //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH.                                      //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// BUFFER SIZES                                                    //// 
.................... //// -------------------------------------------------------------   //// 
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     //// 
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        //// 
.................... ////  Full speed devices limit this value to be 64.  To increase     //// 
.................... ////  the size of the local PIC buffer you can also define           //// 
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        //// 
.................... ////  defined then the total PIC->PC buffer size would be            //// 
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  //// 
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      //// 
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      //// 
.................... ////  then this option isn't used.                                   //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// INTERRUPT LIMITATIONS                                           //// 
.................... //// -------------------------------------------------------------   //// 
.................... //// This section is only relevant if you are using USB interrupts   //// 
.................... ////  and not the USB_ISR_POLLING option.                            //// 
.................... ////                                                                 //// 
.................... //// USB handling is complex, often requiring several packet         //// 
.................... ////  transmissions to accomplish transfer of one block of data.     //// 
.................... ////  Most of this processing is done in the USB ISR.  Because       //// 
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the //// 
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   //// 
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  //// 
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  //// 
.................... ////  overflow the TX buffer than data will be lost.                 //// 
.................... ////                                                                 //// 
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB //// 
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      //// 
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           //// 
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    //// 
.................... ////                                                                 //// 
.................... //// ex_usb_serial3.c shows an example of working around these       //// 
.................... ////  ISR limitations.  Failure to follow these limitations can      //// 
.................... ////  cause the PIC to lockup.  These limtations only need to be     //// 
.................... ////  followed in the conditions listed above (writing code in the   //// 
.................... ////  ISR or interrupts are disabled).                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// Dec 16th, 2013:                                                 //// 
.................... ////  Added encapsulated message support.  See                       //// 
.................... ////     USB_CDC_USE_ENCAPSULATED above for documentation.           //// 
.................... ////                                                                 //// 
.................... //// May 31st, 2013:                                                 //// 
.................... ////  usb_cdc_putready() now returns the number of bytes available.  //// 
.................... ////                                                                 //// 
.................... //// May 23rd, 2013:                                                 //// 
.................... ////  Added usb_cdc_putd().                                          //// 
.................... ////                                                                 //// 
.................... //// February 18th, 2013:                                            //// 
.................... ////  Enhanced PIC16 support added.                                  //// 
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 //// 
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    //// 
.................... ////                                                                 //// 
.................... //// September 13th, 2012:                                           //// 
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     //// 
.................... ////     (PIC24, dsPIC33).                                           //// 
.................... ////  Added usb_cdc_putempty().                                      //// 
.................... ////                                                                 //// 
.................... //// December 16th, 2011:                                            //// 
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will //// 
.................... ////     only include the get string helper functions.  This is      //// 
.................... ////     a rarely used option, used only if you already wrote your   //// 
.................... ////     own getc() and putc() routines.                             //// 
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  //// 
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      //// 
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  //// 
.................... ////                                                                 //// 
.................... //// Oct 27th, 2011:                                                 //// 
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    //// 
.................... ////     documentation.  In order for this to work,                  //// 
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   //// 
.................... ////                                                                 //// 
.................... //// Jan 28, 2010:                                                   //// 
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    //// 
.................... ////     one packet.                                                 //// 
.................... ////                                                                 //// 
.................... //// Jan 25, 2010:                                                   //// 
.................... ////  Ignore incoming 0 length packets.                              //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... #if !defined(__USB_CDC_HELPERS_ONLY__) 
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free()) 
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_tx_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCM__) 
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c 
....................    #elif defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////     PIC18FxxK50                                                 //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 22, 2013:                                                   //// 
.................... ////  Added support for 18F45K50 family.                             //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   1 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==0 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #ifndef __USB_DESCRIPTORS__ 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Oct 27th, 2011:                                                   //// 
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     //// 
.................... ////     send SERIAL_STATE messages in one packet.                     //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #ifndef  USB_CONFIG_PID 
....................    #define  USB_CONFIG_PID       0x000b 
....................    //#define  USB_CONFIG_PID       0x0033    //pre 5.013 value 
.................... #endif 
.................... #ifndef  USB_CONFIG_VID 
....................    #define  USB_CONFIG_VID       0x2405 
....................    //#define  USB_CONFIG_VID       0x0461    //pre 5.013 value 
.................... #endif 
.................... #ifndef  USB_CONFIG_BUS_POWER 
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #endif 
.................... #ifndef  USB_CONFIG_VERSION 
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... #endif 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #ifndef USB_CDC_COMM_IN_SIZE 
.................... #define USB_CDC_COMM_IN_SIZE           11 
.................... #endif 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_IN_SIZE 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #endif 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_OUT_SIZE 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #endif 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1,  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          32, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          ' ',0, 
....................          't',0, 
....................          'o',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'A',0, 
....................          'R',0, 
....................          'T',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// June 8th, 2011:                                                   //// 
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  //// 
.................... ////     (for no timeout) resolved.                                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #if defined(__DO_DEBUG_USB) 
....................    #define debug_usb printf 
....................    void debug_putc(char c) {uart_putc(c);} 
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) { 
....................       unsigned int8 max=16; 
....................       debug_usb(debug_putc,"[%U - ",len); 
....................       //if (max>len) {max=len;} 
....................       max = len; 
....................       while(max--) { 
....................          debug_usb(debug_putc,"%02X",*ptr); 
....................          len--; 
....................          ptr++; 
....................       } 
....................       if (len) {debug_usb(debug_putc,"...");} 
....................       debug_usb(debug_putc,"] "); 
....................    } 
.................... #else 
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................    #define debug_putc(c) 
....................    #define debug_display_ram(x,y) 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16F_USB_H__) 
....................  #include <pic16f_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Dec 17, 2013:                                                   //// 
.................... ////  Added 18FxxJ9x family support.                                 //// 
.................... ////                                                                 //// 
.................... //// Dec 11, 2013:                                                   //// 
.................... ////  Added some LF part support.                                    //// 
.................... ////                                                                 //// 
.................... //// Feb 22, 2013:                                                   //// 
.................... ////  Added support for 18F45K50 family.                             //// 
.................... ////                                                                 //// 
.................... //// July 9th, 2012:                                                 //// 
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     //// 
.................... ////     for non-setup packets on endpoint 0 or all other            //// 
.................... ////     endpoints.  This really only affects people using           //// 
.................... ////     usb_put_packet() or usb_get_packet() inside of other        //// 
.................... ////     interrupts.                                                 //// 
.................... ////                                                                 //// 
.................... //// Sep 22, 2011:                                                   //// 
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   //// 
.................... ////     primarily developed for users developing code where         //// 
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Added initial 18F47J53 family support.                         //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work.                          //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #bit USBIE=getenv("BIT:USBIE") 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... // if only USB_BDT_START is defined, then BDT has a fixed location in RAM 
.................... //    but endpoint memory can be anywhere on the PIC. 
.................... // if only USB_RAM_START is defined, then both BDT and endpoint have a fixed 
.................... //    location in RAM (BDT first, endpoint second). 
.................... // if USB_BDT_START and USB_RAM_START are both defined, then BDT has a fixed 
.................... //    location in RAM and the endpoint buffers have a different location 
.................... //    in RAM. 
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18F24K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18LF24K50")) 
....................  #define __USB_45K50__ 
....................  #define USB_TOTAL_RAM_SPACE  1024 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16  
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................  #define __USB_K50__ //backwards compatability 
....................  #define __USB_14K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \ 
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") || \ 
....................        (getenv("DEVICE")=="PIC18LF26J53") || (getenv("DEVICE")=="PIC18LF27J53") || \  
....................        (getenv("DEVICE")=="PIC18LF46J53") || (getenv("DEVICE")=="PIC18LF47J53") \        
....................        ) 
....................  #define __USB_18FJ53__ 
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use 
....................  #define USB_BDT_START  0xD00 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F97J94") ||  \  
....................        (getenv("DEVICE")=="PIC18F87J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F67J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F96J99") ||  \ 
....................        (getenv("DEVICE")=="PIC18F86J99") ||  \ 
....................        (getenv("DEVICE")=="PIC18F66J99") ||  \ 
....................        (getenv("DEVICE")=="PIC18F96J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F86J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F66J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F95J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F85J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F65J94")) 
....................  #define __USB_18FJ94__ 
....................  #define USB_BDT_START  0x100 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16  
.................... #else  
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying to use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 stat; 
....................    unsigned int8 cnt; 
....................    unsigned int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... #if defined(USB_RAM_START) && !defined(USB_BDT_START) 
....................    #if defined(USB_TOTAL_RAM_SPACE) 
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
....................    #endif 
....................     
....................    struct 
....................    { 
....................       struct 
....................       { 
....................          STRUCT_BD out;    //pc -> pic 
....................          STRUCT_BD in;     //pc <- pic 
....................       } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................       union 
....................       { 
....................          struct 
....................          { 
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................              
....................             //these buffer definitions needed for CDC library 
....................            #if USB_EP1_RX_SIZE 
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................            #endif 
....................            #if USB_EP1_TX_SIZE 
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................            #endif 
....................            #if USB_EP2_RX_SIZE 
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................            #endif 
....................            #if USB_EP2_TX_SIZE 
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................            #endif 
....................          }; 
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................       } buffer; 
....................    } g_USBRAM; 
....................     
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM.buffer) 
....................     
....................    #locate g_USBRAM=USB_RAM_START 
....................     
....................    #define g_USBBDT g_USBRAM.bd 
.................... #else 
....................    #if defined(USB_TOTAL_RAM_SPACE) 
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
....................    #endif 
....................     
....................    struct 
....................    { 
....................       union 
....................       { 
....................          struct 
....................          { 
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................              
....................             //these buffer definitions needed for CDC library 
....................            #if USB_EP1_RX_SIZE 
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................            #endif 
....................            #if USB_EP1_TX_SIZE 
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................            #endif 
....................            #if USB_EP2_RX_SIZE 
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................            #endif 
....................            #if USB_EP2_TX_SIZE 
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................            #endif 
....................          }; 
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................       } buffer; 
....................    } g_USBRAM; 
....................     
....................    #if defined(USB_RAM_START) 
....................       #locate g_USBRAM=USB_RAM_START 
....................    #endif 
....................     
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM) 
....................     
....................    struct 
....................    { 
....................          STRUCT_BD out;    //pc -> pic 
....................          STRUCT_BD in;     //pc <- pic 
....................    } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1]; 
....................     
....................    #locate g_USBBDT=USB_BDT_START 
.................... #endif 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_14K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #elif defined(__USB_18FJ53__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #else 
....................    #byte UFRML = getenv("SFR:UFRML") 
....................    #byte UFRMH = getenv("SFR:UFRMH") 
....................    #byte UIR = getenv("SFR:UIR") 
....................    #byte UIE = getenv("SFR:UIE") 
....................    #byte UEIR = getenv("SFR:UEIR") 
....................    #byte UEIE = getenv("SFR:UEIE") 
....................    #byte U1STAT = getenv("SFR:USTAT") 
....................    #byte UCON = getenv("SFR:UCON") 
....................    #byte UADDR = getenv("SFR:UADDR") 
....................    #byte UCFG = getenv("SFR:UCFG") 
.................... #endif 
....................  
.................... unsigned int8 USTATCopy; 
....................  
.................... unsigned int8 g_UEP[USB_NUM_UEP]; 
.................... #if defined(UEP0_LOC) 
.................... #locate g_UEP=UEP0_LOC 
.................... #else 
.................... #locate g_UEP=getenv("SFR:UEP0") 
.................... #endif 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.BIT_SOF 
.................... #BIT UIE_STALL = UIE.BIT_STALL 
.................... #BIT UIE_IDLE = UIE.BIT_IDLE 
.................... #BIT UIE_TRN = UIE.BIT_TRN 
.................... #BIT UIE_ACTV = UIE.BIT_ACTV 
.................... #BIT UIE_UERR = UIE.BIT_UERR 
.................... #BIT UIE_URST = UIE.BIT_URST 
....................  
.................... #if getenv("BIT_VALID:PPBRST") 
....................    #bit UCON_PPBRST = getenv("BIT:PPBRST") 
.................... #endif 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_14K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... unsigned int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... void usb_isr(void); 
.................... #endif 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
0B60:  CLRF   03
0B62:  MOVF   xDA,W
0B64:  ADDLW  70
0B66:  MOVWF  FE9
0B68:  MOVLW  0F
0B6A:  ADDWFC 03,W
0B6C:  MOVWF  FEA
0B6E:  MOVF   FEF,F
0B70:  BZ    0BA4
0B72:  CLRF   xDC
0B74:  MOVFF  DA,DB
0B78:  CLRF   xDE
0B7A:  MOVLW  08
0B7C:  MOVWF  xDD
0B7E:  CALL   02BC
0B82:  MOVFF  02,DC
0B86:  MOVFF  01,DB
0B8A:  MOVLW  04
0B8C:  ADDWF  xDB,F
0B8E:  MOVLW  00
0B90:  ADDWFC xDC,F
0B92:  MOVFF  DB,FE9
0B96:  MOVLW  04
0B98:  ADDWF  xDC,W
0B9A:  MOVWF  FEA
0B9C:  MOVFF  FEF,DD
0BA0:  BTFSS  xDD.7
0BA2:  BRA    0BA8
0BA4:  MOVLW  00
0BA6:  BRA    0BAA
0BA8:  MOVLW  01
0BAA:  MOVWF  01
0BAC:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON_SUSPND = 0; 
*
1054:  BCF    F6D.1
....................    UCON = 0;  //disable USB hardware 
1056:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
1058:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
105A:  MOVLW  08
105C:  MOVWF  F6F
....................  
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_14K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #elif defined(__USB_18FJ94__) 
....................    output_float(PIN_F4); 
....................    output_float(PIN_F3); 
....................   #elif !defined(USB_PIC_NO_USB_GPIO) 
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5 
105E:  MOVF   F94,W
1060:  IORLW  30
1062:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
1064:  CLRF   31
1066:  CLRF   19
1068:  BTFSC  FF2.7
106A:  BSF    19.7
106C:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
106E:  CALL   03BC
1072:  BTFSC  19.7
1074:  BSF    FF2.7
1076:  GOTO   107C (RETURN)
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
*
1080:  CLRF   19
1082:  BTFSC  FF2.7
1084:  BSF    19.7
1086:  BCF    FF2.7
.................... { 
....................    usb_token_reset(); 
1088:  CALL   03BC
108C:  BTFSC  19.7
108E:  BSF    FF2.7
....................    UCON_SUSPND = 0; 
1090:  BCF    F6D.1
....................    UCON = 0; 
1092:  CLRF   F6D
....................   #if getenv("BIT_VALID:PPBRST") 
....................    UCON_PPBRST = 1; 
1094:  BSF    F6D.6
....................    delay_cycles(5); 
1096:  BRA    1098
1098:  BRA    109A
109A:  NOP   
....................    UCON_PPBRST = 0; 
109C:  BCF    F6D.6
....................   #endif 
....................    UCFG = __UCFG_VAL_ENABLED__; 
109E:  MOVLW  14
10A0:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
10A2:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
10A4:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
10A6:  MOVLW  01
10A8:  MOVWF  31
10AA:  GOTO   10B4 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
107A:  BRA    1054
107C:  GOTO   2362 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................   #if defined(USB_ISR_POLLING) 
....................    if (interrupt_active(INT_USB)) 
....................    { 
....................       usb_isr(); 
....................    } 
....................   #endif 
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_enumerated()) 
....................    { 
....................       usb_cdc_flush_tx_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_attached())  
....................    { 
....................       if (UCON_USBEN==0)  
*
10AE:  BTFSC  F6D.3
10B0:  BRA    10B4
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
10B2:  BRA    1080
....................       } 
....................    } 
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
10B4:  DECFSZ 31,W
10B6:  BRA    10CE
10B8:  BTFSC  F6D.5
10BA:  BRA    10CE
....................    { 
....................       UIR = 0; 
10BC:  CLRF   F68
....................       UIE = 0; 
10BE:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING) 
....................       enable_interrupts(INT_USB); 
10C0:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
10C2:  MOVLW  C0
10C4:  IORWF  FF2,F
....................      #endif 
....................       UIE = __USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
10C6:  MOVLW  11
10C8:  MOVWF  F69
....................      #if USB_USE_ERROR_COUNTER 
....................       UIE |= __USB_UIF_ERROR; 
....................      #endif 
....................       usb_state=USB_STATE_POWERED; 
10CA:  MOVLW  02
10CC:  MOVWF  31
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
10CE:  GOTO   2366 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
....................  
....................    do  
....................    { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
0BAE:  MOVFF  D5,DA
0BB2:  RCALL  0B60
0BB4:  MOVF   01,F
0BB6:  BTFSC  FD8.2
0BB8:  BRA    0CB4
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0BBA:  CLRF   xDC
0BBC:  MOVFF  D5,DB
0BC0:  CLRF   xDE
0BC2:  MOVLW  08
0BC4:  MOVWF  xDD
0BC6:  CALL   02BC
0BCA:  MOVFF  02,DB
0BCE:  MOVFF  01,DA
0BD2:  MOVLW  04
0BD4:  ADDWF  xDA,F
0BD6:  MOVLW  00
0BD8:  ADDWFC xDB,F
0BDA:  MOVLW  01
0BDC:  ADDWF  xDA,W
0BDE:  MOVWF  01
0BE0:  MOVLW  00
0BE2:  ADDWFC xDB,W
0BE4:  MOVWF  03
0BE6:  MOVFF  01,FE9
0BEA:  MOVLW  04
0BEC:  ADDWF  03,W
0BEE:  MOVWF  FEA
0BF0:  MOVFF  D6,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
0BF4:  MOVF   xD8,W
0BF6:  SUBLW  02
0BF8:  BNZ   0C36
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0BFA:  CLRF   xDC
0BFC:  MOVFF  D5,DB
0C00:  CLRF   xDE
0C02:  MOVLW  08
0C04:  MOVWF  xDD
0C06:  CALL   02BC
0C0A:  MOVFF  02,DB
0C0E:  MOVFF  01,DA
0C12:  MOVLW  04
0C14:  ADDWF  xDA,F
0C16:  MOVLW  00
0C18:  ADDWFC xDB,F
0C1A:  MOVFF  DA,FE9
0C1E:  MOVLW  04
0C20:  ADDWF  xDB,W
0C22:  MOVWF  FEA
0C24:  MOVFF  FEF,D9
....................          if (bit_test(i,6)) 
0C28:  BTFSS  xD9.6
0C2A:  BRA    0C30
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0C2C:  CLRF   xD8
0C2E:  BRA    0C34
....................          else 
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0C30:  MOVLW  01
0C32:  MOVWF  xD8
....................       } 
0C34:  BRA    0C66
....................       else if (tgl == USB_DTS_USERX)  
0C36:  MOVF   xD8,W
0C38:  SUBLW  04
0C3A:  BNZ   0C66
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0C3C:  CLRF   xDC
0C3E:  MOVFF  D5,DB
0C42:  CLRF   xDE
0C44:  MOVLW  08
0C46:  MOVWF  xDD
0C48:  CALL   02BC
0C4C:  MOVFF  01,FE9
0C50:  MOVLW  04
0C52:  ADDWF  02,W
0C54:  MOVWF  FEA
0C56:  MOVFF  FEF,D9
....................          if (bit_test(i,6)) 
0C5A:  BTFSS  xD9.6
0C5C:  BRA    0C64
....................             tgl = USB_DTS_DATA1; 
0C5E:  MOVLW  01
0C60:  MOVWF  xD8
0C62:  BRA    0C66
....................          else 
....................             tgl = USB_DTS_DATA0; 
0C64:  CLRF   xD8
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
0C66:  DECFSZ xD8,W
0C68:  BRA    0C70
....................          i=0xC8;  //DATA1, UOWN 
0C6A:  MOVLW  C8
0C6C:  MOVWF  xD9
0C6E:  BRA    0C74
....................       else //if (tgl == USB_DTS_DATA0)  
....................          i=0x88; //DATA0, UOWN 
0C70:  MOVLW  88
0C72:  MOVWF  xD9
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0C74:  BTFSS  xD7.0
0C76:  BRA    0C7A
0C78:  BSF    xD9.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
0C7A:  BTFSS  xD7.1
0C7C:  BRA    0C80
0C7E:  BSF    xD9.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
0C80:  CLRF   xDC
0C82:  MOVFF  D5,DB
0C86:  CLRF   xDE
0C88:  MOVLW  08
0C8A:  MOVWF  xDD
0C8C:  CALL   02BC
0C90:  MOVFF  02,DB
0C94:  MOVFF  01,DA
0C98:  MOVLW  04
0C9A:  ADDWF  xDA,F
0C9C:  MOVLW  00
0C9E:  ADDWFC xDB,F
0CA0:  MOVFF  DA,FE9
0CA4:  MOVLW  04
0CA6:  ADDWF  xDB,W
0CA8:  MOVWF  FEA
0CAA:  MOVFF  D9,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
0CAE:  MOVLW  01
0CB0:  MOVWF  01
0CB2:  BRA    0CB8
....................    } 
....................    else  
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
0CB4:  MOVLW  00
0CB6:  MOVWF  01
0CB8:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
*
0D90:  MOVFF  CD,DA
0D94:  RCALL  0B60
0D96:  MOVF   01,F
0D98:  BZ    0E20
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
0D9A:  CLRF   xDC
0D9C:  MOVFF  CD,DB
0DA0:  CLRF   xDE
0DA2:  MOVLW  08
0DA4:  MOVWF  xDD
0DA6:  CALL   02BC
0DAA:  MOVFF  02,D6
0DAE:  MOVFF  01,D5
0DB2:  MOVLW  04
0DB4:  ADDWF  xD5,F
0DB6:  MOVLW  00
0DB8:  ADDWFC xD6,F
0DBA:  MOVLW  02
0DBC:  ADDWF  xD5,W
0DBE:  MOVWF  01
0DC0:  MOVLW  00
0DC2:  ADDWFC xD6,W
0DC4:  MOVWF  03
0DC6:  MOVFF  01,FE9
0DCA:  MOVLW  04
0DCC:  ADDWF  03,W
0DCE:  MOVWF  FEA
0DD0:  MOVFF  FEC,D4
0DD4:  MOVF   FED,F
0DD6:  MOVFF  FEF,D3
....................       memcpy(buff_add, ptr, len);      
0DDA:  MOVFF  D4,FEA
0DDE:  MOVFF  D3,FE9
0DE2:  MOVFF  CF,FE2
0DE6:  MOVFF  CE,FE1
0DEA:  MOVFF  D1,02
0DEE:  MOVFF  D0,01
0DF2:  MOVF   01,F
0DF4:  BZ    0DFA
0DF6:  INCF   02,F
0DF8:  BRA    0DFE
0DFA:  MOVF   02,F
0DFC:  BZ    0E0A
0DFE:  MOVFF  FE6,FEE
0E02:  DECFSZ 01,F
0E04:  BRA    0DFE
0E06:  DECFSZ 02,F
0E08:  BRA    0DFE
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
0E0A:  MOVFF  CD,D5
0E0E:  MOVFF  D1,D7
0E12:  MOVFF  D0,D6
0E16:  MOVFF  D2,D8
0E1A:  RCALL  0BAE
0E1C:  MOVF   01,W
0E1E:  BRA    0E24
....................    } 
....................    else  
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
0E20:  MOVLW  00
0E22:  MOVWF  01
0E24:  RETURN 0
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
0A7A:  CLRF   xDC
0A7C:  MOVFF  CD,DB
0A80:  CLRF   xDE
0A82:  MOVLW  08
0A84:  MOVWF  xDD
0A86:  RCALL  02BC
0A88:  MOVFF  01,FE9
0A8C:  MOVLW  04
0A8E:  ADDWF  02,W
0A90:  MOVWF  FEA
0A92:  MOVFF  FEF,CF
....................    if (tgl == USB_DTS_TOGGLE)  
0A96:  MOVF   xCE,W
0A98:  SUBLW  02
0A9A:  BNZ   0AA8
....................    { 
....................       if (bit_test(i,6)) 
0A9C:  BTFSS  xCF.6
0A9E:  BRA    0AA4
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0AA0:  CLRF   xCE
0AA2:  BRA    0AA8
....................       else 
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0AA4:  MOVLW  01
0AA6:  MOVWF  xCE
....................    } 
....................    if (tgl == USB_DTS_STALL)  
0AA8:  MOVF   xCE,W
0AAA:  SUBLW  03
0AAC:  BNZ   0AE2
....................    { 
....................       i = 0x84; 
0AAE:  MOVLW  84
0AB0:  MOVWF  xCF
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
0AB2:  CLRF   xDC
0AB4:  MOVFF  CD,DB
0AB8:  CLRF   xDE
0ABA:  MOVLW  08
0ABC:  MOVWF  xDD
0ABE:  CALL   02BC
0AC2:  MOVFF  02,D3
0AC6:  MOVFF  01,D2
0ACA:  MOVLW  04
0ACC:  ADDWF  xD2,F
0ACE:  MOVLW  00
0AD0:  ADDWFC xD3,F
0AD2:  MOVFF  D2,FE9
0AD6:  MOVLW  04
0AD8:  ADDWF  xD3,W
0ADA:  MOVWF  FEA
0ADC:  MOVLW  84
0ADE:  MOVWF  FEF
....................    } 
0AE0:  BRA    0AF0
....................    else if (tgl == USB_DTS_DATA1) 
0AE2:  DECFSZ xCE,W
0AE4:  BRA    0AEC
....................       i = 0xC8;  //DATA1, UOWN 
0AE6:  MOVLW  C8
0AE8:  MOVWF  xCF
0AEA:  BRA    0AF0
....................    else //if (tgl == USB_DTS_DATA0)  
....................       i = 0x88; //DATA0, UOWN 
0AEC:  MOVLW  88
0AEE:  MOVWF  xCF
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
0AF0:  BCF    FD8.0
0AF2:  RLCF   xCD,W
0AF4:  CLRF   03
0AF6:  CALL   011E
0AFA:  TBLRD*+
0AFC:  MOVFF  FF5,03
0B00:  MOVWF  xD0
0B02:  MOVFF  03,D1
....................    EP_BDxCNT_O(endpoint) = len; 
0B06:  CLRF   xDC
0B08:  MOVFF  CD,DB
0B0C:  CLRF   xDE
0B0E:  MOVLW  08
0B10:  MOVWF  xDD
0B12:  CALL   02BC
0B16:  MOVFF  01,D2
0B1A:  MOVLW  01
0B1C:  ADDWF  01,W
0B1E:  MOVWF  01
0B20:  MOVLW  00
0B22:  ADDWFC 02,W
0B24:  MOVWF  03
0B26:  MOVFF  01,FE9
0B2A:  MOVLW  04
0B2C:  ADDWF  03,W
0B2E:  MOVWF  FEA
0B30:  MOVFF  D0,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
0B34:  BTFSS  xD1.0
0B36:  BRA    0B3A
0B38:  BSF    xCF.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
0B3A:  BTFSS  xD1.1
0B3C:  BRA    0B40
0B3E:  BSF    xCF.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
0B40:  CLRF   xDC
0B42:  MOVFF  CD,DB
0B46:  CLRF   xDE
0B48:  MOVLW  08
0B4A:  MOVWF  xDD
0B4C:  CALL   02BC
0B50:  MOVFF  01,FE9
0B54:  MOVLW  04
0B56:  ADDWF  02,W
0B58:  MOVWF  FEA
0B5A:  MOVFF  CF,FEF
0B5E:  RETURN 0
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
0CFA:  CLRF   xDC
0CFC:  MOVFF  CD,DB
0D00:  CLRF   xDE
0D02:  MOVLW  08
0D04:  MOVWF  xDD
0D06:  CALL   02BC
0D0A:  MOVFF  02,CF
0D0E:  MOVFF  01,CE
0D12:  MOVLW  01
0D14:  ADDWF  01,W
0D16:  MOVWF  01
0D18:  MOVLW  00
0D1A:  ADDWFC 02,W
0D1C:  MOVWF  03
0D1E:  MOVFF  01,FE9
0D22:  MOVLW  04
0D24:  ADDWF  03,W
0D26:  MOVWF  FEA
0D28:  CLRF   03
0D2A:  MOVFF  FEF,01
0D2E:  MOVFF  03,02
0D32:  GOTO   0D4C (RETURN)
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    unsigned int8 * al; 
....................    unsigned int8 st; 
....................    unsigned int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0890:  BCF    xCD.0
0892:  BTFSC  xCC.7
0894:  BSF    xCD.0
....................    endpoint &= 0x7F; 
0896:  BCF    xCC.7
....................     
....................    if (direction)  
0898:  BTFSS  xCD.0
089A:  BRA    08CA
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
089C:  CLRF   xDC
089E:  MOVFF  CC,DB
08A2:  CLRF   xDE
08A4:  MOVLW  08
08A6:  MOVWF  xDD
08A8:  RCALL  02BC
08AA:  MOVFF  02,CF
08AE:  MOVFF  01,CE
08B2:  MOVLW  04
08B4:  ADDWF  xCE,F
08B6:  MOVLW  00
08B8:  ADDWFC xCF,F
08BA:  MOVFF  CE,FE9
08BE:  MOVLW  04
08C0:  ADDWF  xCF,W
08C2:  MOVWF  FEA
08C4:  MOVLW  84
08C6:  MOVWF  FEF
....................    } 
08C8:  BRA    08E6
....................    else  
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
08CA:  CLRF   xDC
08CC:  MOVFF  CC,DB
08D0:  CLRF   xDE
08D2:  MOVLW  08
08D4:  MOVWF  xDD
08D6:  RCALL  02BC
08D8:  MOVFF  01,FE9
08DC:  MOVLW  04
08DE:  ADDWF  02,W
08E0:  MOVWF  FEA
08E2:  MOVLW  84
08E4:  MOVWF  FEF
....................    } 
08E6:  GOTO   0984 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0838:  BCF    xCD.0
083A:  BTFSC  xCC.7
083C:  BSF    xCD.0
....................    endpoint &= 0x7F; 
083E:  BCF    xCC.7
....................     
....................    if (direction)  
0840:  BTFSS  xCD.0
0842:  BRA    0872
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
0844:  CLRF   xDC
0846:  MOVFF  CC,DB
084A:  CLRF   xDE
084C:  MOVLW  08
084E:  MOVWF  xDD
0850:  RCALL  02BC
0852:  MOVFF  02,CF
0856:  MOVFF  01,CE
085A:  MOVLW  04
085C:  ADDWF  xCE,F
085E:  MOVLW  00
0860:  ADDWFC xCF,F
0862:  MOVFF  CE,FE9
0866:  MOVLW  04
0868:  ADDWF  xCF,W
086A:  MOVWF  FEA
086C:  MOVLW  88
086E:  MOVWF  FEF
....................      #endif 
....................    } 
0870:  BRA    088C
....................    else  
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
0872:  CLRF   xDC
0874:  MOVFF  CC,DB
0878:  CLRF   xDE
087A:  MOVLW  08
087C:  MOVWF  xDD
087E:  RCALL  02BC
0880:  MOVFF  01,FE9
0884:  MOVLW  04
0886:  ADDWF  02,W
0888:  MOVWF  FEA
088A:  CLRF   FEF
....................    } 
088C:  GOTO   0978 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    unsigned int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
08EA:  BCF    xCD.0
08EC:  BTFSC  xCC.7
08EE:  BSF    xCD.0
....................    endpoint &= 0x7F; 
08F0:  BCF    xCC.7
....................     
....................    if (direction)  
08F2:  BTFSS  xCD.0
08F4:  BRA    0924
....................    { 
....................       st=EP_BDxST_I(endpoint); 
08F6:  CLRF   xDC
08F8:  MOVFF  CC,DB
08FC:  CLRF   xDE
08FE:  MOVLW  08
0900:  MOVWF  xDD
0902:  RCALL  02BC
0904:  MOVFF  02,D0
0908:  MOVFF  01,CF
090C:  MOVLW  04
090E:  ADDWF  xCF,F
0910:  MOVLW  00
0912:  ADDWFC xD0,F
0914:  MOVFF  CF,FE9
0918:  MOVLW  04
091A:  ADDWF  xD0,W
091C:  MOVWF  FEA
091E:  MOVFF  FEF,CE
....................    } 
0922:  BRA    0940
....................    else  
....................    { 
....................       st=EP_BDxST_O(endpoint); 
0924:  CLRF   xDC
0926:  MOVFF  CC,DB
092A:  CLRF   xDE
092C:  MOVLW  08
092E:  MOVWF  xDD
0930:  RCALL  02BC
0932:  MOVFF  01,FE9
0936:  MOVLW  04
0938:  ADDWF  02,W
093A:  MOVWF  FEA
093C:  MOVFF  FEF,CE
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
0940:  BTFSS  xCE.7
0942:  BRA    0948
0944:  BTFSC  xCE.2
0946:  BRA    094C
0948:  MOVLW  00
094A:  BRA    094E
094C:  MOVLW  01
094E:  MOVWF  01
0950:  GOTO   0998 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(unsigned int8 address)  
.................... { 
....................    UADDR = address; 
*
0D6C:  MOVFF  CD,F6E
....................     
....................    if (address)  
0D70:  MOVF   xCD,F
0D72:  BZ    0D7A
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
0D74:  MOVLW  04
0D76:  MOVWF  31
....................    } 
0D78:  BRA    0D7E
....................    else  
....................    { 
....................       usb_state = USB_STATE_POWERED; 
0D7A:  MOVLW  02
0D7C:  MOVWF  31
....................    } 
0D7E:  GOTO   0D8C (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(unsigned int8 config)  
.................... { 
....................    unsigned int8 en; 
....................    unsigned int16 addy; 
....................    unsigned int8 new_uep; 
....................    unsigned int16 len; 
....................    unsigned int8 i; 
....................     
....................    if (config == 0) 
*
055C:  MOVF   xCC,F
055E:  BNZ   0568
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
0560:  MOVLW  04
0562:  MOVWF  31
....................       usb_disable_endpoints(); 
0564:  RCALL  033A
....................    } 
0566:  BRA    06FE
....................    else  
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
0568:  MOVLW  05
056A:  MOVWF  31
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
056C:  MOVLW  04
056E:  MOVWF  xCF
0570:  MOVLW  98
0572:  MOVWF  xCE
....................       for (en=1; en<USB_NUM_UEP; en++)  
0574:  MOVLW  01
0576:  MOVWF  xCD
0578:  MOVF   xCD,W
057A:  SUBLW  0F
057C:  BTFSS  FD8.0
057E:  BRA    06FE
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
0580:  MOVFF  CD,D5
0584:  RCALL  02DA
....................          new_uep = 0; 
0586:  CLRF   xD0
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
0588:  CLRF   03
058A:  MOVF   xCD,W
058C:  RCALL  00CE
058E:  SUBLW  FF
0590:  BZ    0648
....................          { 
....................             new_uep = 0x04; 
0592:  MOVLW  04
0594:  MOVWF  xD0
....................             len = usb_ep_rx_size[en]; 
0596:  BCF    FD8.0
0598:  RLCF   xCD,W
059A:  CLRF   03
059C:  RCALL  011E
059E:  TBLRD*+
05A0:  MOVFF  FF5,03
05A4:  MOVWF  xD1
05A6:  MOVFF  03,D2
....................             EP_BDxCNT_O(en) = len; 
05AA:  CLRF   xDC
05AC:  MOVFF  CD,DB
05B0:  CLRF   xDE
05B2:  MOVLW  08
05B4:  MOVWF  xDD
05B6:  RCALL  02BC
05B8:  MOVFF  01,D4
05BC:  MOVLW  01
05BE:  ADDWF  01,W
05C0:  MOVWF  01
05C2:  MOVLW  00
05C4:  ADDWFC 02,W
05C6:  MOVWF  03
05C8:  MOVFF  01,FE9
05CC:  MOVLW  04
05CE:  ADDWF  03,W
05D0:  MOVWF  FEA
05D2:  MOVFF  D1,FEF
....................             EP_BDxADR_O(en) = addy; 
05D6:  CLRF   xDC
05D8:  MOVFF  CD,DB
05DC:  CLRF   xDE
05DE:  MOVLW  08
05E0:  MOVWF  xDD
05E2:  RCALL  02BC
05E4:  MOVFF  01,D4
05E8:  MOVLW  02
05EA:  ADDWF  01,W
05EC:  MOVWF  01
05EE:  MOVLW  00
05F0:  ADDWFC 02,W
05F2:  MOVWF  03
05F4:  MOVFF  01,FE9
05F8:  MOVLW  04
05FA:  ADDWF  03,W
05FC:  MOVWF  FEA
05FE:  MOVFF  CF,FEC
0602:  MOVF   FED,F
0604:  MOVFF  CE,FEF
....................             addy += usb_ep_rx_size[en]; 
0608:  BCF    FD8.0
060A:  RLCF   xCD,W
060C:  CLRF   03
060E:  RCALL  011E
0610:  TBLRD*+
0612:  MOVFF  FF5,03
0616:  ADDWF  xCE,F
0618:  MOVF   03,W
061A:  ADDWFC xCF,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
061C:  MOVLW  88
061E:  MOVWF  xD3
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
0620:  BTFSS  xD2.0
0622:  BRA    0626
0624:  BSF    xD3.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
0626:  BTFSS  xD2.1
0628:  BRA    062C
062A:  BSF    xD3.1
....................             EP_BDxST_O(en) = i; 
062C:  CLRF   xDC
062E:  MOVFF  CD,DB
0632:  CLRF   xDE
0634:  MOVLW  08
0636:  MOVWF  xDD
0638:  RCALL  02BC
063A:  MOVFF  01,FE9
063E:  MOVLW  04
0640:  ADDWF  02,W
0642:  MOVWF  FEA
0644:  MOVFF  D3,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
0648:  CLRF   03
064A:  MOVF   xCD,W
064C:  RCALL  00AE
064E:  SUBLW  FF
0650:  BZ    06D2
....................          { 
....................             new_uep |= 0x02; 
0652:  BSF    xD0.1
....................             EP_BDxADR_I(en) = addy; 
0654:  CLRF   xDC
0656:  MOVFF  CD,DB
065A:  CLRF   xDE
065C:  MOVLW  08
065E:  MOVWF  xDD
0660:  RCALL  02BC
0662:  MOVFF  02,D5
0666:  MOVFF  01,D4
066A:  MOVLW  04
066C:  ADDWF  xD4,F
066E:  MOVLW  00
0670:  ADDWFC xD5,F
0672:  MOVLW  02
0674:  ADDWF  xD4,W
0676:  MOVWF  01
0678:  MOVLW  00
067A:  ADDWFC xD5,W
067C:  MOVWF  03
067E:  MOVFF  01,FE9
0682:  MOVLW  04
0684:  ADDWF  03,W
0686:  MOVWF  FEA
0688:  MOVFF  CF,FEC
068C:  MOVF   FED,F
068E:  MOVFF  CE,FEF
....................             addy += usb_ep_tx_size[en]; 
0692:  BCF    FD8.0
0694:  RLCF   xCD,W
0696:  CLRF   03
0698:  RCALL  00EE
069A:  TBLRD*+
069C:  MOVFF  FF5,03
06A0:  ADDWF  xCE,F
06A2:  MOVF   03,W
06A4:  ADDWFC xCF,F
....................             EP_BDxST_I(en) = 0x40; 
06A6:  CLRF   xDC
06A8:  MOVFF  CD,DB
06AC:  CLRF   xDE
06AE:  MOVLW  08
06B0:  MOVWF  xDD
06B2:  RCALL  02BC
06B4:  MOVFF  02,D5
06B8:  MOVFF  01,D4
06BC:  MOVLW  04
06BE:  ADDWF  xD4,F
06C0:  MOVLW  00
06C2:  ADDWFC xD5,F
06C4:  MOVFF  D4,FE9
06C8:  MOVLW  04
06CA:  ADDWF  xD5,W
06CC:  MOVWF  FEA
06CE:  MOVLW  40
06D0:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
06D2:  MOVF   xD0,W
06D4:  SUBLW  06
06D6:  BNZ   06DC
06D8:  MOVLW  0E
06DA:  MOVWF  xD0
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
06DC:  CLRF   03
06DE:  MOVF   xCD,W
06E0:  RCALL  00AE
06E2:  SUBLW  01
06E4:  BZ    06E8
06E6:  BSF    xD0.4
....................           
....................          UEP(en) = new_uep; 
06E8:  CLRF   03
06EA:  MOVF   xCD,W
06EC:  ADDLW  70
06EE:  MOVWF  FE9
06F0:  MOVLW  0F
06F2:  ADDWFC 03,W
06F4:  MOVWF  FEA
06F6:  MOVFF  D0,FEF
06FA:  INCF   xCD,F
06FC:  BRA    0578
....................       } 
....................    } 
06FE:  GOTO   079C (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(unsigned int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
02DA:  CLRF   03
02DC:  MOVF   xD5,W
02DE:  ADDLW  70
02E0:  MOVWF  FE9
02E2:  MOVLW  0F
02E4:  ADDWFC 03,W
02E6:  MOVWF  FEA
02E8:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
02EA:  MOVFF  D5,D6
02EE:  RCALL  027A
02F0:  MOVF   01,F
02F2:  BZ    0338
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
02F4:  CLRF   xDC
02F6:  MOVFF  D5,DB
02FA:  CLRF   xDE
02FC:  MOVLW  08
02FE:  MOVWF  xDD
0300:  RCALL  02BC
0302:  MOVFF  01,FE9
0306:  MOVLW  04
0308:  ADDWF  02,W
030A:  MOVWF  FEA
030C:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
030E:  CLRF   xDC
0310:  MOVFF  D5,DB
0314:  CLRF   xDE
0316:  MOVLW  08
0318:  MOVWF  xDD
031A:  RCALL  02BC
031C:  MOVFF  02,D7
0320:  MOVFF  01,D6
0324:  MOVLW  04
0326:  ADDWF  xD6,F
0328:  MOVLW  00
032A:  ADDWFC xD7,F
032C:  MOVFF  D6,FE9
0330:  MOVLW  04
0332:  ADDWF  xD7,W
0334:  MOVWF  FEA
0336:  CLRF   FEF
....................    } 
0338:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    unsigned int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
033A:  MOVLW  01
033C:  MOVWF  xD4
033E:  MOVF   xD4,W
0340:  SUBLW  0F
0342:  BNC   034E
....................       usb_disable_endpoint(i); 
0344:  MOVFF  D4,D5
0348:  RCALL  02DA
034A:  INCF   xD4,F
034C:  BRA    033E
034E:  RETURN 0
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR) 
.................... #int_usb NOCLEAR 
.................... #endif 
.................... void usb_isr(void) 
.................... { 
....................    unsigned int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
0F3A:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
0F3C:  MOVF   31,F
0F3E:  BTFSC  FD8.2
0F40:  BRA    0FA8
....................    if (UIR)  
0F42:  MOVF   F68,F
0F44:  BTFSC  FD8.2
0F46:  BRA    0FA8
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
0F48:  BTFSS  F68.2
0F4A:  BRA    0F52
0F4C:  BTFSC  F69.2
0F4E:  GOTO   022A
....................  
....................       if (UCON_SUSPND) return; 
0F52:  BTFSC  F6D.1
0F54:  BRA    0FA8
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
0F56:  BTFSS  F68.5
0F58:  BRA    0F60
0F5A:  BTFSC  F69.5
0F5C:  GOTO   0264
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
0F60:  BTFSS  F68.1
0F62:  BRA    0F6A
0F64:  BTFSC  F69.1
0F66:  GOTO   0272
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
0F6A:  BTFSS  F68.0
0F6C:  BRA    0F74
0F6E:  BTFSC  F69.0
0F70:  GOTO   03E8
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
0F74:  BTFSS  F68.4
0F76:  BRA    0F7E
0F78:  BTFSC  F69.4
0F7A:  GOTO   0412
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
0F7E:  BTFSS  F68.6
0F80:  BRA    0F88
0F82:  BTFSC  F69.6
0F84:  GOTO   041C
....................  
....................       TRNAttempts = 0; 
0F88:  CLRF   xC9
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
0F8A:  BTFSS  F68.3
0F8C:  BRA    0F9E
0F8E:  BTFSS  F69.3
0F90:  BRA    0F9E
....................          { 
....................             USTATCopy = U1STAT; 
0F92:  MOVFF  F6C,30
....................             usb_clear_trn(); 
0F96:  CALL   0004
....................             usb_isr_tok_dne(); 
0F9A:  BRA    0E70
....................          } 
0F9C:  BRA    0FA0
....................          else 
....................             break; 
0F9E:  BRA    0FA8
....................       } while (TRNAttempts++ < 4); 
0FA0:  MOVF   xC9,W
0FA2:  INCF   xC9,F
0FA4:  SUBLW  03
0FA6:  BC    0F8A
....................  
....................      #if defined(USB_CDC_ISR) 
....................       //has to be done here, can't be done until TRN is empty. 
....................       if (usb_cdc_kbhit()) 
....................       { 
....................          USB_CDC_ISR(); 
....................       } 
....................      #endif 
....................    } 
0FA8:  GOTO   0060
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
041C:  BCF    F68.6
041E:  GOTO   0F88 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
03E8:  CLRF   F6A
....................    UIR = 0; 
03EA:  CLRF   F68
....................    UEIE = 0x9F; 
03EC:  MOVLW  9F
03EE:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
03F0:  MOVLW  3D
03F2:  MOVWF  F69
....................  
....................    UADDR = 0; 
03F4:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
03F6:  RCALL  033A
....................     
....................    usb_token_reset(); 
03F8:  RCALL  03BC
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
03FA:  MOVLW  16
03FC:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
03FE:  BTFSS  F68.3
0400:  BRA    0406
....................    { 
....................       usb_clear_trn(); 
0402:  RCALL  0004
0404:  BRA    03FE
....................    } 
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
0406:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
0408:  RCALL  023A
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
040A:  MOVLW  03
040C:  MOVWF  31
040E:  GOTO   0F74 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
023A:  MOVLW  40
023C:  MOVLB  4
023E:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
0240:  MOVLW  04
0242:  MOVLB  0
0244:  MOVWF  xCB
0246:  MOVLW  18
0248:  MOVFF  CB,403
024C:  MOVFF  FE8,402
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
0250:  MOVLW  88
0252:  MOVLB  4
0254:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
0256:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
0258:  MOVLW  04
025A:  MOVWF  x07
025C:  MOVLW  58
025E:  MOVWF  x06
0260:  MOVLB  0
0262:  RETURN 0
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
0272:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
0274:  BCF    F68.1
0276:  GOTO   0F6A (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
0412:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
0414:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
0416:  BSF    F6D.1
0418:  GOTO   0F7E (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
022A:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
022C:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
022E:  BTFSS  F68.2
0230:  BRA    0236
....................    { 
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
0232:  BCF    F68.2
0234:  BRA    022E
....................    } 
0236:  GOTO   0F52 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
0264:  BTFSS  F70.0
0266:  BRA    026C
....................    { 
....................       usb_init_ep0_setup(); 
0268:  RCALL  023A
....................       bit_clear(UEP(0), 0); 
026A:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
026C:  BCF    F68.5
026E:  GOTO   0F60 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0422:  MOVFF  CF,32
0426:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
*
09B2:  MOVLW  FE
09B4:  MOVWF  32
09B6:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
*
0428:  SETF   32
042A:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    unsigned int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
0E70:  RRCF   30,W
0E72:  MOVWF  xCA
0E74:  RRCF   xCA,F
0E76:  RRCF   xCA,F
0E78:  MOVLW  1F
0E7A:  ANDWF  xCA,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
0E7C:  MOVF   30,F
0E7E:  BNZ   0F02
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
0E80:  MOVLB  4
0E82:  MOVF   x00,W
0E84:  ANDLW  3C
0E86:  MOVLB  0
0E88:  MOVWF  xCB
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
0E8A:  MOVLW  43
0E8C:  MOVLB  4
0E8E:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
0E90:  MOVLB  0
0E92:  MOVF   xCB,W
0E94:  SUBLW  34
0E96:  BNZ   0ED4
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
0E98:  MOVLB  4
0E9A:  MOVF   x04,W
0E9C:  ANDLW  80
0E9E:  BZ    0EA2
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
0EA0:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
0EA2:  MOVLB  0
0EA4:  BRA    0A48
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
0EA6:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
0EA8:  INCFSZ 32,W
0EAA:  BRA    0EB6
....................             usb_flush_out(0, USB_DTS_STALL); 
0EAC:  CLRF   xCD
0EAE:  MOVLW  03
0EB0:  MOVWF  xCE
0EB2:  RCALL  0A7A
0EB4:  BRA    0ED2
....................          else  
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
0EB6:  CLRF   xCD
0EB8:  MOVLW  02
0EBA:  MOVWF  xCE
0EBC:  RCALL  0A7A
....................             if (__setup_0_tx_size != 0xFE) 
0EBE:  MOVF   32,W
0EC0:  SUBLW  FE
0EC2:  BZ    0ED2
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
0EC4:  CLRF   xD5
0EC6:  CLRF   xD7
0EC8:  MOVFF  32,D6
0ECC:  MOVLW  04
0ECE:  MOVWF  xD8
0ED0:  RCALL  0BAE
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
0ED2:  BRA    0F00
....................       else if (pidKey == USB_PIC_PID_OUT)  
0ED4:  MOVF   xCB,W
0ED6:  SUBLW  04
0ED8:  BNZ   0F00
....................       { 
....................          usb_isr_tok_out_dne(0); 
0EDA:  CLRF   xCC
0EDC:  RCALL  0D5A
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
0EDE:  CLRF   xCD
0EE0:  MOVLW  02
0EE2:  MOVWF  xCE
0EE4:  RCALL  0A7A
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
0EE6:  MOVF   32,W
0EE8:  SUBLW  FE
0EEA:  BZ    0F00
0EEC:  INCFSZ 32,W
0EEE:  BRA    0EF2
0EF0:  BRA    0F00
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
0EF2:  CLRF   xD5
0EF4:  CLRF   xD7
0EF6:  MOVFF  32,D6
0EFA:  MOVLW  01
0EFC:  MOVWF  xD8
0EFE:  RCALL  0BAE
....................          } 
....................       } 
....................       else 
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
0F00:  BRA    0F36
....................    else if (USTATCopy == USTAT_IN_E0)  
0F02:  MOVF   30,W
0F04:  SUBLW  04
0F06:  BNZ   0F24
....................    {    
....................       //pic -> host transfer completed 
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion 
....................       __setup_0_tx_size = 0xFF; 
0F08:  SETF   32
....................       usb_isr_tok_in_dne(0); 
0F0A:  CLRF   xCC
0F0C:  RCALL  0E4E
....................       if (__setup_0_tx_size!=0xFF) 
0F0E:  INCFSZ 32,W
0F10:  BRA    0F14
0F12:  BRA    0F22
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
0F14:  CLRF   xD5
0F16:  CLRF   xD7
0F18:  MOVFF  32,D6
0F1C:  MOVLW  02
0F1E:  MOVWF  xD8
0F20:  RCALL  0BAE
....................       else 
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
0F22:  BRA    0F36
....................    else  
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
0F24:  BTFSC  30.2
0F26:  BRA    0F30
....................       { 
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_out_dne(en); 
0F28:  MOVFF  CA,CC
0F2C:  RCALL  0D5A
....................       } 
0F2E:  BRA    0F36
....................       else  
....................       { 
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_in_dne(en); 
0F30:  MOVFF  CA,CC
0F34:  RCALL  0E4E
....................       } 
....................    } 
0F36:  GOTO   0F9C (RETURN)
.................... } 
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1)) 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  64 
.................... #else 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  8 
.................... #endif 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
10D2:  MOVF   27,W
10D4:  MOVWF  01
10D6:  GOTO   117E (RETURN)
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    usb_getdesc_len = 0; 
*
03BC:  CLRF   37
03BE:  CLRF   36
....................     
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
03C0:  CLRF   xCA
03C2:  MOVF   xCA,W
03C4:  SUBLW  01
03C6:  BNC   03DC
....................       USB_Interface[i] = 0;   //reset each interface to default 
03C8:  CLRF   03
03CA:  MOVF   xCA,W
03CC:  ADDLW  38
03CE:  MOVWF  FE9
03D0:  MOVLW  00
03D2:  ADDWFC 03,W
03D4:  MOVWF  FEA
03D6:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
03D8:  INCF   xCA,F
03DA:  BRA    03C2
....................    usb_cdc_init(); 
03DC:  RCALL  0350
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
03DE:  CLRF   27
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
03E0:  MOVLW  01
03E2:  MOVWF  28
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
03E4:  CLRF   26
03E6:  RETURN 0
.................... } 
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
027A:  BCF    xD7.0
027C:  BTFSC  xD6.7
027E:  BSF    xD7.0
....................     
....................    endpoint &= 0x7F; 
0280:  BCF    xD6.7
....................     
....................    if (endpoint > 16) 
0282:  MOVF   xD6,W
0284:  SUBLW  10
0286:  BC    028E
....................       return(FALSE); 
0288:  MOVLW  00
028A:  MOVWF  01
028C:  BRA    02BA
....................     
....................    if (direction) { //IN 
028E:  BTFSS  xD7.0
0290:  BRA    02A8
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
0292:  CLRF   03
0294:  MOVF   xD6,W
0296:  RCALL  00AE
0298:  SUBLW  FF
029A:  BNZ   02A0
029C:  MOVLW  00
029E:  BRA    02A2
02A0:  MOVLW  01
02A2:  MOVWF  01
02A4:  BRA    02BA
....................    } 
02A6:  BRA    02BA
....................    else {   //OUT 
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
02A8:  CLRF   03
02AA:  MOVF   xD6,W
02AC:  RCALL  00CE
02AE:  SUBLW  FF
02B0:  BNZ   02B6
02B2:  MOVLW  00
02B4:  BRA    02B8
02B6:  MOVLW  01
02B8:  MOVWF  01
....................    } 
02BA:  RETURN 0
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) { 
....................    if (endpoint==0) { 
*
0E4E:  MOVF   xCC,F
0E50:  BNZ   0E66
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
0E52:  DECFSZ 26,W
0E54:  BRA    0E5C
0E56:  CALL   042C
0E5A:  BRA    0E64
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
0E5C:  MOVF   26,W
0E5E:  SUBLW  02
0E60:  BTFSC  FD8.2
0E62:  BRA    0D82
....................    } 
....................   #if USB_CDC_DEVICE 
0E64:  BRA    0E6E
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0E66:  MOVF   xCC,W
0E68:  SUBLW  02
0E6A:  BNZ   0E6E
....................       usb_isr_tok_in_cdc_data_dne(); 
0E6C:  BRA    0E48
....................   } 
....................   #endif 
0E6E:  RETURN 0
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0D5A:  MOVF   xCC,F
0D5C:  BNZ   0D62
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
0D5E:  BRA    0CBA
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
0D60:  BRA    0D6A
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0D62:  MOVF   xCC,W
0D64:  SUBLW  02
0D66:  BNZ   0D6A
....................       usb_isr_tok_out_cdc_data_dne(); 
0D68:  BRA    0D42
....................    } 
....................   #endif 
0D6A:  RETURN 0
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
0A48:  CLRF   26
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
0A4A:  MOVLB  4
0A4C:  MOVF   x18,W
0A4E:  ANDLW  7F
0A50:  XORLW  00
0A52:  MOVLB  0
0A54:  BZ    0A64
0A56:  XORLW  01
0A58:  BZ    0A68
0A5A:  XORLW  03
0A5C:  BZ    0A6C
0A5E:  XORLW  23
0A60:  BZ    0A70
0A62:  BRA    0A74
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
0A64:  BRA    0702
....................          break; 
0A66:  BRA    0A76
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
0A68:  BRA    07AC
....................          break; 
0A6A:  BRA    0A76
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
0A6C:  BRA    0954
....................          break; 
0A6E:  BRA    0A76
....................           
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc, " class"); 
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE 
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE) 
....................          { 
....................             usb_isr_tkn_setup_ClassInterface(); 
....................          } 
....................          else 
....................          { 
....................             usb_isr_tkn_cdc(); 
....................          } 
....................         #elif USB_HID_DEVICE 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................         #else 
....................          usb_isr_tkn_cdc(); 
0A70:  BRA    09B8
....................         #endif 
....................          break; 
0A72:  BRA    0A76
.................... #endif 
....................  
....................  
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
0A74:  RCALL  0428
....................          break; 
....................    } 
0A76:  GOTO   0EA6 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
0702:  MOVLB  4
0704:  MOVF   x19,W
0706:  XORLW  00
0708:  MOVLB  0
070A:  BZ    0726
070C:  XORLW  01
070E:  BZ    0738
0710:  XORLW  02
0712:  BZ    0752
0714:  XORLW  06
0716:  BZ    076A
0718:  XORLW  03
071A:  BZ    0778
071C:  XORLW  0E
071E:  BZ    077C
0720:  XORLW  01
0722:  BZ    0788
0724:  BRA    07A6
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
0726:  MOVFF  28,458
....................             usb_ep0_tx_buffer[1]=0; 
072A:  MOVLB  4
072C:  CLRF   x59
....................             usb_request_send_response(2); 
072E:  MOVLW  02
0730:  MOVLB  0
0732:  MOVWF  xCF
0734:  RCALL  0422
....................             break; 
0736:  BRA    07A8
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0738:  MOVLB  4
073A:  DECFSZ x1A,W
073C:  BRA    074C
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
073E:  MOVLW  01
0740:  ANDWF  28,F
....................                usb_put_0len_0(); 
0742:  MOVLB  0
0744:  CLRF   xCF
0746:  RCALL  0422
....................             } 
0748:  BRA    0750
074A:  MOVLB  4
....................             else 
....................                usb_request_stall(); 
074C:  MOVLB  0
074E:  RCALL  0428
....................             break; 
0750:  BRA    07A8
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0752:  MOVLB  4
0754:  DECFSZ x1A,W
0756:  BRA    0764
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
0758:  BSF    28.1
....................                usb_put_0len_0(); 
075A:  MOVLB  0
075C:  CLRF   xCF
075E:  RCALL  0422
....................             } 
0760:  BRA    0768
0762:  MOVLB  4
....................             else 
....................                usb_request_stall(); 
0764:  MOVLB  0
0766:  RCALL  0428
....................             break; 
0768:  BRA    07A8
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
076A:  MOVLW  02
076C:  MOVWF  26
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
076E:  MOVFF  41A,33
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
0772:  CLRF   xCF
0774:  RCALL  0422
....................             break; 
0776:  BRA    07A8
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
0778:  BRA    04A4
....................             break; 
077A:  BRA    07A8
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
077C:  MOVFF  27,458
....................             usb_request_send_response(1); 
0780:  MOVLW  01
0782:  MOVWF  xCF
0784:  RCALL  0422
....................             break; 
0786:  BRA    07A8
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
0788:  MOVLB  4
078A:  MOVF   x1A,W
078C:  SUBLW  01
078E:  BNC   07A2
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
0790:  MOVFF  41A,27
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
0794:  MOVFF  41A,CC
0798:  MOVLB  0
079A:  BRA    055C
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
079C:  CLRF   xCF
079E:  RCALL  0422
07A0:  MOVLB  4
....................             } 
....................             break; 
07A2:  MOVLB  0
07A4:  BRA    07A8
....................  
....................       default: 
....................             usb_request_stall(); 
07A6:  RCALL  0428
....................             break; 
....................    } 
07A8:  GOTO   0A76 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    unsigned int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
07AC:  MOVFF  27,CC
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
07B0:  MOVLB  4
07B2:  MOVF   x19,W
07B4:  XORLW  00
07B6:  MOVLB  0
07B8:  BZ    07C4
07BA:  XORLW  0A
07BC:  BZ    07D4
07BE:  XORLW  01
07C0:  BZ    080E
07C2:  BRA    0832
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
07C4:  MOVLB  4
07C6:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0; 
07C8:  CLRF   x59
....................             usb_request_send_response(2); 
07CA:  MOVLW  02
07CC:  MOVLB  0
07CE:  MOVWF  xCF
07D0:  RCALL  0422
....................             break; 
07D2:  BRA    0834
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
07D4:  MOVF   xCC,F
07D6:  BZ    080A
07D8:  MOVLW  01
07DA:  SUBWF  xCC,W
07DC:  CLRF   03
07DE:  RCALL  01A2
07E0:  MOVWF  01
07E2:  MOVLB  4
07E4:  SUBWF  x1C,W
07E6:  BTFSS  FD8.0
07E8:  BRA    07EE
07EA:  MOVLB  0
07EC:  BRA    080A
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
07EE:  CLRF   03
07F0:  MOVF   x1C,W
07F2:  ADDLW  38
07F4:  MOVWF  FE9
07F6:  MOVLW  00
07F8:  ADDWFC 03,W
07FA:  MOVWF  FEA
07FC:  MOVFF  FEF,458
....................                usb_request_send_response(1); //send byte back 
0800:  MOVLW  01
0802:  MOVLB  0
0804:  MOVWF  xCF
0806:  RCALL  0422
....................             } 
0808:  BRA    080C
....................             else 
....................                usb_request_stall(); 
080A:  RCALL  0428
....................             break; 
080C:  BRA    0834
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
080E:  MOVF   xCC,F
0810:  BZ    082E
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
0812:  CLRF   03
0814:  MOVLB  4
0816:  MOVF   x1C,W
0818:  ADDLW  38
081A:  MOVWF  FE9
081C:  MOVLW  00
081E:  ADDWFC 03,W
0820:  MOVWF  FEA
0822:  MOVFF  41A,FEF
....................                usb_put_0len_0(); 
0826:  MOVLB  0
0828:  CLRF   xCF
082A:  RCALL  0422
....................             } 
082C:  BRA    0830
....................             else 
....................                usb_request_stall(); 
082E:  RCALL  0428
....................             break; 
0830:  BRA    0834
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GDh"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
0832:  RCALL  0428
....................             break; 
....................    } 
0834:  GOTO   0A76 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
0954:  MOVFF  41C,D6
0958:  RCALL  027A
095A:  MOVF   01,F
095C:  BZ    09AE
....................       switch(usb_ep0_rx_buffer[1]) { 
095E:  MOVLB  4
0960:  MOVF   x19,W
0962:  XORLW  01
0964:  MOVLB  0
0966:  BZ    0972
0968:  XORLW  02
096A:  BZ    097E
096C:  XORLW  03
096E:  BZ    098A
0970:  BRA    09AC
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
0972:  MOVFF  41C,CC
0976:  BRA    0838
....................                usb_put_0len_0(); 
0978:  CLRF   xCF
097A:  RCALL  0422
....................                break; 
097C:  BRA    09AE
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
097E:  MOVFF  41C,CC
0982:  BRA    0890
....................                      usb_put_0len_0(); 
0984:  CLRF   xCF
0986:  RCALL  0422
....................                      break; 
0988:  BRA    09AE
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
098A:  MOVLB  4
098C:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0; 
098E:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
0990:  MOVFF  41C,CC
0994:  MOVLB  0
0996:  BRA    08EA
0998:  MOVF   01,F
099A:  BZ    09A4
....................                   usb_ep0_tx_buffer[0]=1; 
099C:  MOVLW  01
099E:  MOVLB  4
09A0:  MOVWF  x58
09A2:  MOVLB  0
....................                } 
....................                usb_request_send_response(2); 
09A4:  MOVLW  02
09A6:  MOVWF  xCF
09A8:  RCALL  0422
....................                break; 
09AA:  BRA    09AE
....................  
....................          default: 
....................             usb_request_stall(); 
09AC:  RCALL  0428
....................             break; 
....................       } 
....................    } 
09AE:  GOTO   0A76 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
04A4:  CLRF   35
04A6:  CLRF   34
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
04A8:  CLRF   29
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
04AA:  MOVLB  4
04AC:  MOVF   x1B,W
04AE:  XORLW  01
04B0:  MOVLB  0
04B2:  BZ    04C2
04B4:  XORLW  03
04B6:  BZ    04CE
04B8:  XORLW  01
04BA:  BZ    04D6
04BC:  XORLW  22
04BE:  BZ    0504
04C0:  BRA    0536
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
04C2:  CLRF   37
04C4:  MOVLW  12
04C6:  MOVWF  36
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
04C8:  MOVLW  03
04CA:  MOVWF  29
....................             break; 
04CC:  BRA    053A
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
04CE:  CLRF   37
04D0:  MOVLW  43
04D2:  MOVWF  36
....................             break; 
04D4:  BRA    053A
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
04D6:  MOVLW  02
04D8:  MOVWF  29
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
04DA:  CLRF   03
04DC:  MOVLB  4
04DE:  MOVF   x1A,W
04E0:  ADDLW  2A
04E2:  MOVWF  FE9
04E4:  MOVLW  00
04E6:  ADDWFC 03,W
04E8:  MOVWF  FEA
04EA:  CLRF   35
04EC:  MOVFF  FEF,34
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
04F0:  MOVFF  35,03
04F4:  MOVF   34,W
04F6:  MOVLB  0
04F8:  RCALL  01EE
04FA:  CLRF   03
04FC:  MOVWF  36
04FE:  MOVFF  03,37
....................             break; 
0502:  BRA    053A
....................  
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06 
....................       // this is needed so host can find out about differences about this 
....................       // devices ability to handle full speed verses fast speed. 
....................       // since we don't support fast speed then we ignore this. 
....................       //      break; 
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
0504:  CLRF   03
0506:  MOVLB  4
0508:  MOVF   x1A,W
050A:  MOVLB  0
050C:  RCALL  01B4
050E:  CLRF   03
0510:  MOVWF  34
0512:  MOVFF  03,35
....................             if (usb_getdesc_ptr!=0xFF) { 
0516:  INCFSZ 34,W
0518:  BRA    051E
051A:  MOVF   35,F
051C:  BZ    0532
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
051E:  MOVFF  35,03
0522:  MOVF   34,W
0524:  RCALL  014E
0526:  CLRF   03
0528:  MOVWF  36
052A:  MOVFF  03,37
....................                break; 
052E:  BRA    053A
....................             } 
0530:  BRA    0536
....................             else { 
....................                usb_request_stall(); 
0532:  RCALL  0428
....................                return; 
0534:  BRA    0558
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
0536:  RCALL  0428
....................             return; 
0538:  BRA    0558
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
053A:  MOVLB  4
053C:  MOVF   x1F,F
053E:  BNZ   0550
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
0540:  MOVF   37,F
0542:  BNZ   054A
0544:  MOVF   36,W
0546:  SUBWF  x1E,W
0548:  BC    0550
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
054A:  CLRF   37
054C:  MOVFF  41E,36
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
0550:  MOVLW  01
0552:  MOVWF  26
....................    usb_copy_desc_seg_to_ep(); 
0554:  MOVLB  0
0556:  RCALL  042C
0558:  GOTO   07A8 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
0D82:  CLRF   27
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
0D84:  CLRF   26
....................    usb_set_address(USB_address_pending); 
0D86:  MOVFF  33,CD
0D8A:  BRA    0D6C
....................    #endif 
0D8C:  GOTO   0E64 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
042C:  CLRF   xCD
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]); 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
042E:  MOVF   36,W
0430:  IORWF  37,W
0432:  BZ    048E
0434:  MOVF   xCD,W
0436:  SUBLW  3F
0438:  BNC   048E
....................    { 
....................       switch(USB_stack_status.getdesc_type) { 
043A:  MOVF   29,W
043C:  BZ    0448
043E:  XORLW  02
0440:  BZ    0454
0442:  XORLW  01
0444:  BZ    0460
0446:  BRA    046A
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
0448:  MOVFF  35,03
044C:  MOVF   34,W
044E:  RCALL  014E
0450:  MOVWF  xCE
....................             break; 
0452:  BRA    046A
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
0454:  MOVFF  35,03
0458:  MOVF   34,W
045A:  RCALL  01EE
045C:  MOVWF  xCE
....................             break; 
045E:  BRA    046A
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
0460:  MOVFF  35,03
0464:  MOVF   34,W
0466:  RCALL  01CC
0468:  MOVWF  xCE
....................             //debug_usb(debug_putc, "-%X- ", c); 
....................             break; 
....................       } 
....................       usb_getdesc_ptr++; 
046A:  INCF   34,F
046C:  BTFSC  FD8.2
046E:  INCF   35,F
....................       usb_getdesc_len--; 
0470:  MOVF   36,W
0472:  BTFSC  FD8.2
0474:  DECF   37,F
0476:  DECF   36,F
....................       usb_ep0_tx_buffer[i++]=c; 
0478:  MOVF   xCD,W
047A:  INCF   xCD,F
047C:  ADDLW  58
047E:  MOVWF  FE9
0480:  MOVLW  04
0482:  MOVWF  FEA
0484:  BTFSC  FD8.0
0486:  INCF   FEA,F
0488:  MOVFF  CE,FEF
048C:  BRA    042E
....................    } 
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
048E:  MOVF   36,W
0490:  IORWF  37,W
0492:  BNZ   049C
0494:  MOVF   xCD,W
0496:  SUBLW  40
0498:  BZ    049C
....................          USB_stack_status.dev_req = NONE; 
049A:  CLRF   26
....................    } 
....................  
....................    usb_request_send_response(i); 
049C:  MOVFF  CD,CF
04A0:  RCALL  0422
04A2:  RETURN 0
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /* 
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary 
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk 
....................    transfer endpoints is not supported on slow speed devices per the USB 
....................    specification.  You may be able to find unofficial drivers for your 
....................    operating system that allows CDC to operate on a slow speed device, 
....................    but CCS doesn't have any that they can recommend to you. 
.................... */ 
.................... #if (USB_USE_FULL_SPEED==0) 
....................    #error CDC and slow speed is not supported.  See comments above. 
.................... #endif 
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE 
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #else 
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE]; 
.................... #endif 
....................  
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this. 
....................  typedef unsigned int16 usb_cdc_tx_t; 
.................... #else 
....................  typedef unsigned int8 usb_cdc_tx_t; 
.................... #endif 
....................  
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin; 
....................  
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state; 
....................  
.................... /* 
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
.................... */ 
....................  
.................... #if defined(USB_CDC_USE_ENCAPSULATED) 
.................... unsigned int16 g_UsbCdcSendEncapsSize; 
.................... #endif 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
0CBA:  MOVF   x84,W
0CBC:  XORLW  01
0CBE:  BZ    0CC6
0CC0:  XORLW  03
0CC2:  BZ    0CD0
0CC4:  BRA    0CF4
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................         #if defined(USB_CDC_USE_ENCAPSULATED) 
....................          usb_cdc_SendEncapsulatedCommand(usb_ep0_rx_buffer, g_UsbCdcSendEncapsSize); 
....................         #endif 
....................          usb_put_0len_0(); 
0CC6:  CLRF   xCF
0CC8:  CALL   0422
....................          __usb_cdc_state=0; 
0CCC:  CLRF   x84
....................          break; 
0CCE:  BRA    0CF6
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................          break; 
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
0CD0:  CLRF   FEA
0CD2:  MOVLW  3A
0CD4:  MOVWF  FE9
0CD6:  MOVLW  04
0CD8:  MOVWF  FE2
0CDA:  MOVLW  18
0CDC:  MOVWF  FE1
0CDE:  MOVLW  07
0CE0:  MOVWF  01
0CE2:  MOVFF  FE6,FEE
0CE6:  DECFSZ 01,F
0CE8:  BRA    0CE2
....................          __usb_cdc_state=0; 
0CEA:  CLRF   x84
....................          usb_put_0len_0(); 
0CEC:  CLRF   xCF
0CEE:  CALL   0422
....................          break; 
0CF2:  BRA    0CF6
....................  
....................       default: 
....................          __usb_cdc_state=0; 
0CF4:  CLRF   x84
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
....................    } 
0CF6:  GOTO   0D60 (RETURN)
.................... } 
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    unsigned int16 wLen; 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
09B8:  MOVLB  4
09BA:  DECFSZ x1C,W
09BC:  BRA    09C0
09BE:  BRA    09C4
09C0:  MOVF   x1C,F
09C2:  BNZ   0A42
....................       wLen = make16(usb_ep0_rx_buffer[7], usb_ep0_rx_buffer[6]); 
09C4:  MOVFF  41F,CD
09C8:  MOVFF  41E,CC
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
09CC:  MOVF   x19,W
09CE:  XORLW  00
09D0:  MOVLB  0
09D2:  BZ    09EA
09D4:  XORLW  01
09D6:  BZ    09F2
09D8:  XORLW  21
09DA:  BZ    09FA
09DC:  XORLW  01
09DE:  BZ    0A04
09E0:  XORLW  03
09E2:  BZ    0A26
09E4:  XORLW  01
09E6:  BZ    0A30
09E8:  BRA    0A3E
....................          case 0x00:  //send_encapsulated_command 
....................            #if defined(USB_CDC_USE_ENCAPSULATED) 
....................             g_UsbCdcSendEncapsSize = wLen; 
....................            #endif 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
09EA:  MOVLW  01
09EC:  MOVWF  x84
....................             usb_request_get_data(); 
09EE:  RCALL  09B2
....................             break; 
09F0:  BRA    0A40
....................  
....................          case 0x01:  //get_encapsulated_command 
....................            #if defined(USB_CDC_USE_ENCAPSULATED) 
....................             usb_cdc_GetEncapsulatedResponse(usb_ep0_tx_buffer, wLen); 
....................            #endif 
....................             usb_request_send_response(wLen); 
09F2:  MOVFF  CC,CF
09F6:  RCALL  0422
....................             break; 
09F8:  BRA    0A40
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
09FA:  MOVLW  02
09FC:  MOVWF  x84
....................             usb_cdc_got_set_line_coding=TRUE; 
09FE:  BSF    1A.1
....................             usb_request_get_data(); 
0A00:  RCALL  09B2
....................             break; 
0A02:  BRA    0A40
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
0A04:  MOVLW  04
0A06:  MOVWF  FEA
0A08:  MOVLW  58
0A0A:  MOVWF  FE9
0A0C:  CLRF   FE2
0A0E:  MOVLW  3A
0A10:  MOVWF  FE1
0A12:  MOVLW  07
0A14:  MOVWF  01
0A16:  MOVFF  FE6,FEE
0A1A:  DECFSZ 01,F
0A1C:  BRA    0A16
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
0A1E:  MOVLW  07
0A20:  MOVWF  xCF
0A22:  RCALL  0422
....................             break; 
0A24:  BRA    0A40
....................  
....................          case 0x22:  //set_control_line_state 
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
0A26:  MOVFF  41A,83
....................             usb_put_0len_0(); 
0A2A:  CLRF   xCF
0A2C:  RCALL  0422
....................             break; 
0A2E:  BRA    0A40
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
0A30:  MOVFF  41A,42
0A34:  MOVFF  41B,41
....................             usb_put_0len_0(); 
0A38:  CLRF   xCF
0A3A:  RCALL  0422
....................             break; 
0A3C:  BRA    0A40
....................  
....................          default: 
....................             usb_request_stall(); 
0A3E:  RCALL  0428
....................             break; 
0A40:  MOVLB  4
....................       } 
....................    } 
0A42:  MOVLB  0
0A44:  GOTO   0A76 (RETURN)
.................... } 
....................  
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
0D42:  BSF    2D.0
....................    usb_cdc_get_buffer_status.index=0; 
0D44:  CLRF   2F
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
0D46:  MOVLW  02
0D48:  MOVWF  xCD
0D4A:  BRA    0CFA
0D4C:  MOVFF  01,2E
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
....................    if (!usb_cdc_get_buffer_status.len) 
0D50:  MOVF   2E,F
0D52:  BNZ   0D56
....................    { 
....................       usb_cdc_get_discard(); 
0D54:  RCALL  0D36
....................    } 
0D56:  GOTO   0D6A (RETURN)
....................    /* 
....................   #if defined(USB_CDC_ISR) 
....................    else 
....................    { 
....................       USB_CDC_ISR(); 
....................    } 
....................   #endif 
....................   */ 
.................... } 
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    usb_cdc_flush_tx_buffer(); 
*
0E48:  RCALL  0E26
0E4A:  GOTO   0E6E (RETURN)
.................... } 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void usb_cdc_flush_tx_buffer(void)  
.................... { 
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE 
....................    usb_cdc_tx_t n; 
....................   #endif 
....................    
....................    if (usb_cdc_put_buffer_nextin != 0) 
*
0E26:  MOVF   x82,F
0E28:  BZ    0E46
....................    { 
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE)) 
0E2A:  MOVLW  02
0E2C:  MOVWF  xCD
0E2E:  CLRF   xCF
0E30:  MOVLW  43
0E32:  MOVWF  xCE
0E34:  CLRF   xD1
0E36:  MOVFF  82,D0
0E3A:  MOVLW  02
0E3C:  MOVWF  xD2
0E3E:  RCALL  0D90
0E40:  MOVF   01,F
0E42:  BZ    0E46
....................       { 
....................          usb_cdc_put_buffer_nextin = 0; 
0E44:  CLRF   x82
....................       } 
....................      #else 
....................       n = usb_cdc_put_buffer_nextin; 
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets 
....................          n = USB_CDC_DATA_IN_SIZE-1; 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE)) 
....................       { 
....................          //pull the buffer back 
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n); 
....................          usb_cdc_put_buffer_nextin -= n; 
....................       }       
....................      #endif 
....................    } 
0E46:  RETURN 0
.................... } 
....................  
.................... void usb_cdc_init(void)  
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 115200; 
*
0350:  CLRF   xCE
0352:  MOVLW  01
0354:  MOVWF  xCD
0356:  MOVLW  C2
0358:  MOVWF  xCC
035A:  CLRF   xCB
035C:  CLRF   FEA
035E:  MOVLW  3A
0360:  MOVWF  FE9
0362:  CLRF   FE2
0364:  MOVLW  CB
0366:  MOVWF  FE1
0368:  MOVLW  04
036A:  MOVWF  01
036C:  MOVFF  FE6,FEE
0370:  DECFSZ 01,F
0372:  BRA    036C
....................    usb_cdc_line_coding.bCharFormat = 0; 
0374:  CLRF   xCB
0376:  CLRF   FEA
0378:  MOVLW  3E
037A:  MOVWF  FE9
037C:  CLRF   FE2
037E:  MOVLW  CB
0380:  MOVWF  FE1
0382:  MOVFF  FE6,FEE
....................    usb_cdc_line_coding.bParityType = 0; 
0386:  CLRF   xCB
0388:  CLRF   FEA
038A:  MOVLW  3F
038C:  MOVWF  FE9
038E:  CLRF   FE2
0390:  MOVLW  CB
0392:  MOVWF  FE1
0394:  MOVFF  FE6,FEE
....................    usb_cdc_line_coding.bDataBits = 8; 
0398:  MOVLW  08
039A:  MOVWF  xCB
039C:  CLRF   FEA
039E:  MOVLW  40
03A0:  MOVWF  FE9
03A2:  CLRF   FE2
03A4:  MOVLW  CB
03A6:  MOVWF  FE1
03A8:  MOVFF  FE6,FEE
....................    (int8)usb_cdc_carrier = 0; 
03AC:  CLRF   x83
....................    usb_cdc_got_set_line_coding = FALSE; 
03AE:  BCF    1A.1
....................    usb_cdc_break = 0; 
03B0:  CLRF   42
03B2:  CLRF   41
....................    usb_cdc_put_buffer_nextin = 0; 
03B4:  CLRF   x82
....................    usb_cdc_get_buffer_status.got = 0; 
03B6:  BCF    2D.0
....................    __usb_cdc_state = 0; 
03B8:  CLRF   x84
03BA:  RETURN 0
.................... } 
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD. 
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR 
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device. 
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device.  
....................    unsigned int bFraming:1;   //A framing error has occurred. 
....................    unsigned int bParity:1;    //A parity error has occurred. 
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device. 
....................    unsigned int reserved0:1;   //future use 
....................    unsigned int reserved1:8;   //future use 
.................... } cdc_serial_state_t; 
....................  
.................... /* 
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring,  
....................    break signal and more (see cdc_serial_state_t). 
....................    Some of these values are held by the host (meaning it's value only needs 
....................    to be sent on change), but some values are one shot (meaning you continously 
....................    need to send value to host while being held). 
.................... */ 
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state) 
.................... { 
....................   #if __USB_PIC_PERIF__ 
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer 
....................   #else 
....................    unsigned int8 payload[10]; 
....................    #define CDC_EP1_NOTIFY_BUFFER payload 
....................   #endif 
....................  
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT)) 
....................       return(FALSE); 
....................  
....................    //bmRequestType 
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001 
....................    //bNotification 
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE 
....................    //wValue 
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0; 
....................    //wIndex 
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0; 
....................    //wLength 
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t) 
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0; 
....................    //data 
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state; 
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8; 
....................  
....................   #if __USB_PIC_PERIF__ 
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE); 
....................   #else 
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE); 
....................   #endif 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
*
0D36:  BCF    2D.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
0D38:  MOVLW  02
0D3A:  MOVWF  xCD
0D3C:  MOVWF  xCE
0D3E:  RCALL  0A7A
0D40:  RETURN 0
.................... } 
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit())  
*
11DE:  BTFSC  2D.0
11E0:  BRA    11E4
....................    { 
....................      #if defined(USB_ISR_POLLING) 
11E2:  BRA    11DE
....................       usb_task(); 
....................      #endif 
....................    } 
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
11E4:  MOVF   2F,W
11E6:  INCF   2F,F
11E8:  ADDLW  A3
11EA:  MOVWF  FE9
11EC:  MOVLW  04
11EE:  MOVWF  FEA
11F0:  BTFSC  FD8.0
11F2:  INCF   FEA,F
11F4:  MOVFF  FEF,99
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
11F8:  MOVF   2E,W
11FA:  SUBWF  2F,W
11FC:  BNC   120C
11FE:  CLRF   19
1200:  BTFSC  FF2.7
1202:  BSF    19.7
1204:  BCF    FF2.7
....................    { 
....................       usb_cdc_get_discard(); 
1206:  RCALL  0D36
1208:  BTFSC  19.7
120A:  BSF    FF2.7
....................    } 
....................  
....................    return(c); 
120C:  MOVFF  99,01
1210:  RETURN 0
.................... } 
....................  
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0 
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1 
....................  
.................... static void _usb_cdc_putc_fast_noflush(char c) 
.................... { 
....................    __USB_PAUSE_ISR(); 
*
10FE:  BCF    xB7.0
1100:  BTFSC  FA0.5
1102:  BSF    xB7.0
1104:  BCF    FA0.5
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer))  
....................    { 
....................       usb_cdc_flush_tx_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
1106:  MOVF   x82,W
1108:  SUBLW  3E
110A:  BC    1110
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
110C:  MOVLW  3E
110E:  MOVWF  x82
....................    } 
....................     
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
1110:  MOVF   x82,W
1112:  INCF   x82,F
1114:  CLRF   03
1116:  ADDLW  43
1118:  MOVWF  FE9
111A:  MOVLW  00
111C:  ADDWFC 03,W
111E:  MOVWF  FEA
1120:  MOVFF  B6,FEF
....................  
....................    __USB_RESTORE_ISR(); 
1124:  BTFSS  xB7.0
1126:  BRA    112A
1128:  BSF    FA0.5
112A:  GOTO   1134 (RETURN)
.................... } 
....................  
.................... void usb_cdc_putc_fast(char c) 
.................... { 
....................    _usb_cdc_putc_fast_noflush(c); 
112E:  MOVFF  B5,B6
1132:  BRA    10FE
1134:  CLRF   19
1136:  BTFSC  FF2.7
1138:  BSF    19.7
113A:  BCF    FF2.7
....................  
....................   #if defined(USB_ISR_POLLING) 
....................    // if interrupts are disabled, we should clear all activity isrs 
....................    // before we attempt to put any data onto an endpoint. 
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) 
....................       return; 
....................    usb_task(); 
....................   #endif 
....................    
....................   #if !defined(USB_CDC_DELAYED_FLUSH) 
....................    //if (usb_cdc_put_buffer_free())  
....................    { 
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_tx_buffer(); 
113C:  RCALL  0E26
113E:  BTFSC  19.7
1140:  BSF    FF2.7
....................    } 
....................   #endif 
1142:  GOTO   1156 (RETURN)
....................  
....................    //putc('*'); 
.................... } 
....................  
.................... void usb_cdc_putc(char c) 
.................... { 
....................    while (!usb_cdc_putready())  
1146:  MOVLW  3F
1148:  BSF    FD8.0
114A:  SUBFWB x82,W
114C:  BNZ   1150
....................    { 
....................      #if 0 
....................       if (usb_cdc_put_buffer_free())  
....................       { 
....................          //printf("FL1 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................          usb_cdc_flush_tx_buffer(); 
....................       } 
....................      #endif 
....................      #if defined(USB_ISR_POLLING) 
114E:  BRA    1146
....................       usb_task(); 
....................      #endif      
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
....................    //putc('.'); 
....................    //putc(c); 
....................    usb_cdc_putc_fast(c); 
1150:  MOVFF  B4,B5
1154:  BRA    112E
1156:  RETURN 0
.................... } 
....................  
.................... int1 usb_cdc_putd(unsigned char *ptr, unsigned int8 len) 
.................... { 
....................  #if USB_EP2_TX_SIZE>=0x100 
....................    unsigned int16 i; 
....................  #else 
....................    unsigned int8 i; 
....................  #endif 
....................    char c; 
....................     
....................    i = 0; 
....................     
....................    if (!usb_cdc_put_buffer_free()) 
....................       return(FALSE); 
....................     
....................    while(len--) 
....................    { 
....................       c = *ptr++; 
....................       _usb_cdc_putc_fast_noflush(c); 
....................       if (++i >= USB_EP2_TX_SIZE) 
....................          break; 
....................    } 
....................     
....................    usb_cdc_flush_tx_buffer(); 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... int1 usb_cdc_puts(char *ptr) 
.................... {    
....................    unsigned int8 len; 
....................  
....................    len = strlen(ptr); 
....................    
....................    return(usb_cdc_putd(ptr, len)); 
.................... } 
....................  
.................... #endif //__USB_CDC_HELPERS_ONLY__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // If you are using a USB connection sense pin, define it here.  If you are  
.................... // not using connection sense, comment out this line.  Without connection  
.................... // sense you will not know if the device gets disconnected.  
.................... //       (connection sense should look like this:  
.................... //                             100k  
.................... //            VBUS-----+----/\/\/\/\/\----- (I/O PIN ON PIC)  
.................... //                     |  
.................... //                     +----/\/\/\/\/\-----GND  
.................... //                             100k  
.................... //        (where VBUS is pin1 of the USB connector)  
.................... //  
.................... /////////////////////////////////////////////////////////////////////////////  
.................... ///only the 18F4550 development kit has this pin  
.................... //#if __USB_PIC_PERIF__ && defined(__PCH__)  
.................... // #define USB_CON_SENSE_PIN PIN_B2  
.................... //#endif  
....................  
.................... /////////////////////////////////////////////////////////////////////////////  
....................  
.................... char swich1 = 'f'; 
.................... char swich2 = 'f'; 
.................... float temperature; 
.................... byte sec,min,hour,day,month,year; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////  
.................... //  
.................... // usb_debug_task()  
.................... //  
.................... // When called periodically, displays debugging information over serial  
.................... // to display enumeration and connection states.  Also lights LED1 based upon  
.................... // enumeration and status.  
.................... //  
.................... /////////////////////////////////////////////////////////////////////////////  
.................... void usb_debug_task(void) {  
....................    static int8 last_connected;  
....................    static int8 last_enumerated;  
....................    int8 new_connected;  
....................    int8 new_enumerated;  
....................    static int8 last_cdc;  
....................    int8 new_cdc;  
....................  
....................    new_connected=usb_attached();  
*
1178:  MOVLW  01
117A:  MOVWF  x98
....................    new_enumerated=usb_enumerated();  
117C:  BRA    10D2
117E:  MOVFF  01,99
....................    new_cdc=usb_cdc_connected();  
1182:  CLRF   x9A
1184:  BTFSC  1A.1
1186:  INCF   x9A,F
....................  
....................    if (new_enumerated)  
1188:  MOVF   x99,F
118A:  BZ    1192
....................       LED_ON(LED_GREEN);  
118C:  BCF    F96.2
118E:  BCF    F8D.2
1190:  BRA    1196
....................    else  
....................       LED_OFF(LED_GREEN);  
1192:  BCF    F96.2
1194:  BSF    F8D.2
....................  
....................    if (new_cdc)  
1196:  MOVF   x9A,F
1198:  BZ    11A0
....................       LED_ON(LED_GREEN);  
119A:  BCF    F96.2
119C:  BCF    F8D.2
119E:  BRA    11A4
....................    else  
....................       LED_OFF(LED_GREEN);  
11A0:  BCF    F96.2
11A2:  BSF    F8D.2
....................  
....................    if (usb_cdc_carrier.dte_present)  
11A4:  BTFSS  x83.0
11A6:  BRA    11AE
....................       LED_ON(LED_RED);  
11A8:  BCF    F94.0
11AA:  BCF    F8B.0
11AC:  BRA    11B2
....................    else  
....................       LED_OFF(LED_RED);  
11AE:  BCF    F94.0
11B0:  BSF    F8B.0
....................  
....................    /* 
....................    if (new_connected && !last_connected){ 
....................       printf("USB connected, waiting for enumaration...\r\n\n");  
....................    } 
....................    if (!new_connected && last_connected){ 
....................       printf("USB disconnected, waiting for connection...\r\n\n");  
....................    } 
....................    if (new_enumerated && !last_enumerated){  
....................       printf("USB enumerated by PC/HOST\r\n\n");  
....................    } 
....................    if (!new_enumerated && last_enumerated){  
....................       printf("USB unenumerated by PC/HOST, waiting for enumeration...\r\n\n");  
....................    } 
....................    */ 
....................    if (new_cdc && !last_cdc) {  
11B2:  MOVF   x9A,F
11B4:  BZ    11CE
11B6:  MOVF   x95,F
11B8:  BNZ   11CE
....................       printf("\nTTMSB - NoweEnergie.org\n");  
11BA:  MOVLW  AC
11BC:  MOVWF  FF6
11BE:  MOVLW  0F
11C0:  MOVWF  FF7
11C2:  BRA    10DA
....................       printf(usb_cdc_putc, "\nTTMSB - NoweEnergie.org\n");  
11C4:  MOVLW  C6
11C6:  MOVWF  FF6
11C8:  MOVLW  0F
11CA:  MOVWF  FF7
11CC:  RCALL  1158
....................    }  
....................  
....................    last_connected=new_connected;  
11CE:  MOVFF  98,93
....................    last_enumerated=new_enumerated;  
11D2:  MOVFF  99,94
....................    last_cdc=new_cdc;  
11D6:  MOVFF  9A,95
11DA:  GOTO   236A (RETURN)
.................... }  
.................... //////////////////////////URZADZENIA PERYFERYJNE////////////////////////////////////////////////  
....................  
....................  
.................... void blink_green(){ 
....................         LED_ON(LED_GREEN); 
*
122E:  BCF    F96.2
1230:  BCF    F8D.2
....................         delay_ms (300); 
1232:  MOVLW  02
1234:  MOVWF  x98
1236:  MOVLW  96
1238:  MOVWF  xB6
123A:  RCALL  1014
123C:  DECFSZ x98,F
123E:  BRA    1236
....................         LED_OFF(LED_GREEN); 
1240:  BCF    F96.2
1242:  BSF    F8D.2
....................         delay_ms (300); 
1244:  MOVLW  02
1246:  MOVWF  x98
1248:  MOVLW  96
124A:  MOVWF  xB6
124C:  RCALL  1014
124E:  DECFSZ x98,F
1250:  BRA    1248
....................         LED_ON(LED_GREEN); 
1252:  BCF    F96.2
1254:  BCF    F8D.2
....................         delay_ms (300); 
1256:  MOVLW  02
1258:  MOVWF  x98
125A:  MOVLW  96
125C:  MOVWF  xB6
125E:  RCALL  1014
1260:  DECFSZ x98,F
1262:  BRA    125A
....................         LED_OFF(LED_GREEN); 
1264:  BCF    F96.2
1266:  BSF    F8D.2
1268:  RETURN 0
.................... } 
....................  
.................... void beep() 
.................... { 
....................    Output_high (PIN_B4) ; 
*
103C:  BCF    F93.4
103E:  BSF    F8A.4
....................    delay_ms (1000) ; 
1040:  MOVLW  04
1042:  MOVWF  x98
1044:  MOVLW  FA
1046:  MOVWF  xB6
1048:  RCALL  1014
104A:  DECFSZ x98,F
104C:  BRA    1044
....................    Output_low (PIN_B4) ; 
104E:  BCF    F93.4
1050:  BCF    F8A.4
1052:  RETURN 0
.................... } 
....................  
.................... void relay1() 
.................... { 
....................    //jesli wylaczony to wlaczyc 
....................    if (swich1 == 'f') 
*
1212:  MOVF   x87,W
1214:  SUBLW  66
1216:  BNZ   1222
....................    { 
....................       Output_high (PIN_D0) ; 
1218:  BCF    F95.0
121A:  BSF    F8C.0
....................       swich1 = 'n'; 
121C:  MOVLW  6E
121E:  MOVWF  x87
....................    } 
1220:  BRA    122A
....................  
....................    //byl wlaczony to wylaczyc 
....................    else 
....................    { 
....................       Output_low (PIN_D0) ; 
1222:  BCF    F95.0
1224:  BCF    F8C.0
....................       swich1 = 'f'; 
1226:  MOVLW  66
1228:  MOVWF  x87
....................    } 
122A:  GOTO   23C2 (RETURN)
.................... } 
....................  
....................  
.................... void relay2() 
.................... { 
....................    //jesli wylaczony to wlaczyc 
....................    if (swich2 == 'f') 
*
126A:  MOVF   x88,W
126C:  SUBLW  66
126E:  BNZ   127A
....................    { 
....................       Output_high (PIN_D1) ; 
1270:  BCF    F95.1
1272:  BSF    F8C.1
....................       swich2 = 'n'; 
1274:  MOVLW  6E
1276:  MOVWF  x88
....................    } 
1278:  BRA    1282
....................  
....................    //byl wlaczony to wylaczyc 
....................    else 
....................    { 
....................       Output_low (PIN_D1) ; 
127A:  BCF    F95.1
127C:  BCF    F8C.1
....................       swich2 = 'f'; 
127E:  MOVLW  66
1280:  MOVWF  x88
....................    } 
1282:  GOTO   23CC (RETURN)
.................... } 
....................  
.................... //w gore (EN_A IN1) 
.................... void up() 
.................... { 
....................    Output_high (PIN_D3) ; 
1286:  BCF    F95.3
1288:  BSF    F8C.3
....................    Output_high (PIN_D2) ; 
128A:  BCF    F95.2
128C:  BSF    F8C.2
....................    delay_ms (100) ; 
128E:  MOVLW  64
1290:  MOVWF  xB6
1292:  RCALL  1014
....................    Output_low (PIN_D3) ; 
1294:  BCF    F95.3
1296:  BCF    F8C.3
....................    Output_low (PIN_D2) ; 
1298:  BCF    F95.2
129A:  BCF    F8C.2
129C:  GOTO   249E (RETURN)
.................... } 
....................  
.................... //w dol (EN_A IN2) 
.................... void down() 
.................... { 
....................    Output_high (PIN_D3) ; 
12A0:  BCF    F95.3
12A2:  BSF    F8C.3
....................    Output_high (PIN_D4) ; 
12A4:  BCF    F95.4
12A6:  BSF    F8C.4
....................    delay_ms (100) ; 
12A8:  MOVLW  64
12AA:  MOVWF  xB6
12AC:  RCALL  1014
....................    Output_low (PIN_D3) ; 
12AE:  BCF    F95.3
12B0:  BCF    F8C.3
....................    Output_low (PIN_D4) ; 
12B2:  BCF    F95.4
12B4:  BCF    F8C.4
12B6:  GOTO   249E (RETURN)
.................... } 
....................  
.................... //w prawo (EN_B IN3) 
.................... void right() 
.................... { 
....................    Output_high (PIN_D6) ; 
*
12D4:  BCF    F95.6
12D6:  BSF    F8C.6
....................    Output_high (PIN_D5) ; 
12D8:  BCF    F95.5
12DA:  BSF    F8C.5
....................    delay_ms (100) ; 
12DC:  MOVLW  64
12DE:  MOVWF  xB6
12E0:  RCALL  1014
....................    Output_low (PIN_D6) ; 
12E2:  BCF    F95.6
12E4:  BCF    F8C.6
....................    Output_low (PIN_D5) ; 
12E6:  BCF    F95.5
12E8:  BCF    F8C.5
12EA:  GOTO   249E (RETURN)
.................... } 
....................  
.................... //w lewo (EN_B IN4) 
.................... void left() 
.................... { 
....................    Output_high (PIN_D6) ; 
*
12BA:  BCF    F95.6
12BC:  BSF    F8C.6
....................    Output_high (PIN_D7) ; 
12BE:  BCF    F95.7
12C0:  BSF    F8C.7
....................    delay_ms (100) ; 
12C2:  MOVLW  64
12C4:  MOVWF  xB6
12C6:  RCALL  1014
....................    Output_low (PIN_D6) ; 
12C8:  BCF    F95.6
12CA:  BCF    F8C.6
....................    Output_low (PIN_D7) ; 
12CC:  BCF    F95.7
12CE:  BCF    F8C.7
12D0:  GOTO   249E (RETURN)
.................... } 
....................  
.................... //ustawianie zegara 
.................... void set_time() 
.................... { 
....................    unsigned int t; 
....................     
....................    printf(usb_cdc_putc, "\nday"); 
*
1476:  MOVLW  E0
1478:  MOVWF  FF6
147A:  MOVLW  0F
147C:  MOVWF  FF7
147E:  RCALL  1158
....................    t = usb_cdc_getc();  
1480:  RCALL  11DE
1482:  MOVFF  01,98
....................    write_ds1307 (4, decToBcd(t)); //day 
1486:  MOVFF  98,99
148A:  RCALL  1316
148C:  MOVFF  01,99
1490:  MOVLW  04
1492:  MOVWF  x9A
1494:  MOVFF  01,9B
1498:  RCALL  13A6
....................  
....................    printf(usb_cdc_putc, "\nmonth"); 
149A:  MOVLW  E6
149C:  MOVWF  FF6
149E:  MOVLW  0F
14A0:  MOVWF  FF7
14A2:  RCALL  1158
....................    t = usb_cdc_getc(); 
14A4:  RCALL  11DE
14A6:  MOVFF  01,98
....................    write_ds1307 (5, decToBcd(t)); //month 
14AA:  MOVFF  98,99
14AE:  RCALL  1316
14B0:  MOVFF  01,99
14B4:  MOVLW  05
14B6:  MOVWF  x9A
14B8:  MOVFF  01,9B
14BC:  RCALL  13A6
....................  
....................    printf(usb_cdc_putc, "\nyear"); 
14BE:  MOVLW  EE
14C0:  MOVWF  FF6
14C2:  MOVLW  0F
14C4:  MOVWF  FF7
14C6:  RCALL  1158
....................    t = usb_cdc_getc(); 
14C8:  RCALL  11DE
14CA:  MOVFF  01,98
....................    write_ds1307 (6, decToBcd(t)); //year 
14CE:  MOVFF  98,99
14D2:  RCALL  1316
14D4:  MOVFF  01,99
14D8:  MOVLW  06
14DA:  MOVWF  x9A
14DC:  MOVFF  01,9B
14E0:  RCALL  13A6
....................  
....................    printf(usb_cdc_putc, "\nhour"); 
14E2:  MOVLW  F4
14E4:  MOVWF  FF6
14E6:  MOVLW  0F
14E8:  MOVWF  FF7
14EA:  RCALL  1158
....................    t = usb_cdc_getc(); 
14EC:  RCALL  11DE
14EE:  MOVFF  01,98
....................    write_ds1307 (2, decToBcd(t)); //hour 
14F2:  MOVFF  98,99
14F6:  RCALL  1316
14F8:  MOVFF  01,99
14FC:  MOVLW  02
14FE:  MOVWF  x9A
1500:  MOVFF  01,9B
1504:  RCALL  13A6
....................  
....................    printf(usb_cdc_putc, "\nmin"); 
1506:  MOVLW  FA
1508:  MOVWF  FF6
150A:  MOVLW  0F
150C:  MOVWF  FF7
150E:  RCALL  1158
....................    t = usb_cdc_getc(); 
1510:  RCALL  11DE
1512:  MOVFF  01,98
....................    write_ds1307 (1, decToBcd(t)); //minute 
1516:  MOVFF  98,99
151A:  RCALL  1316
151C:  MOVFF  01,99
1520:  MOVLW  01
1522:  MOVWF  x9A
1524:  MOVFF  01,9B
1528:  RCALL  13A6
....................  
....................    printf(usb_cdc_putc, "\nsek"); 
152A:  MOVLW  00
152C:  MOVWF  FF6
152E:  MOVLW  10
1530:  MOVWF  FF7
1532:  RCALL  1158
....................    t = usb_cdc_getc(); 
1534:  RCALL  11DE
1536:  MOVFF  01,98
....................    write_ds1307 (0, decToBcd(t)); //second 
153A:  MOVFF  98,99
153E:  RCALL  1316
1540:  MOVFF  01,99
1544:  CLRF   x9A
1546:  MOVFF  01,9B
154A:  RCALL  13A6
154C:  GOTO   23F4 (RETURN)
.................... } 
....................  
.................... //czytanie zegara 
.................... void read_time() 
.................... { 
....................    sec = bcdToDec(read_ds1307 (0)); // read second 
*
1662:  CLRF   x98
1664:  RCALL  15B8
1666:  MOVFF  01,98
166A:  MOVFF  01,99
166E:  RCALL  1648
1670:  MOVFF  01,8D
....................    min = bcdToDec(read_ds1307 (1)); // read minute 
1674:  MOVLW  01
1676:  MOVWF  x98
1678:  RCALL  15B8
167A:  MOVFF  01,98
167E:  MOVFF  01,99
1682:  RCALL  1648
1684:  MOVFF  01,8E
....................    hour = bcdToDec(read_ds1307 (2)); // read hour 
1688:  MOVLW  02
168A:  MOVWF  x98
168C:  RCALL  15B8
168E:  MOVFF  01,98
1692:  MOVFF  01,99
1696:  RCALL  1648
1698:  MOVFF  01,8F
....................    day = bcdToDec(read_ds1307 (4)); // read day 
169C:  MOVLW  04
169E:  MOVWF  x98
16A0:  RCALL  15B8
16A2:  MOVFF  01,98
16A6:  MOVFF  01,99
16AA:  RCALL  1648
16AC:  MOVFF  01,90
....................    month = bcdToDec(read_ds1307 (5)); // read month 
16B0:  MOVLW  05
16B2:  MOVWF  x98
16B4:  RCALL  15B8
16B6:  MOVFF  01,98
16BA:  MOVFF  01,99
16BE:  RCALL  1648
16C0:  MOVFF  01,91
....................    year = bcdToDec(read_ds1307 (6)); // read year 
16C4:  MOVLW  06
16C6:  MOVWF  x98
16C8:  RCALL  15B8
16CA:  MOVFF  01,98
16CE:  MOVFF  01,99
16D2:  RCALL  1648
16D4:  MOVFF  01,92
16D8:  GOTO   23FE (RETURN)
.................... } 
....................  
....................  
.................... void json_temp(){ 
....................         sint16 temperature_raw;     /* temperature raw value (resolution 1/256ï¿½C) */ 
....................         float temperature_float; 
....................         char temperature[8];        /* temperature as string */ 
....................         uint8 sensor_count;         /* sensor counter */ 
....................       
....................                 sensor_count = 0; 
*
2250:  CLRF   xA6
....................                 printf(usb_cdc_putc,"{"); 
2252:  MOVLW  7B
2254:  MOVWF  xB4
2256:  CALL   1146
....................                 if ( DS1820_FindFirstDevice() ){ 
225A:  GOTO   198E
225E:  MOVF   01,F
2260:  BZ    22F4
....................                         do 
....................                         { 
....................                                 /* get temperature raw value (resolution 1/256ï¿½C) */ 
....................                                 temperature_raw = DS1820_GetTempRaw(); 
2262:  CALL   1A50
2266:  MOVFF  02,99
226A:  MOVFF  01,98
....................                                 /* convert raw temperature to string for output */ 
....................                                 DS1820_GetTempString(temperature_raw, temperature); 
226E:  MOVFF  99,A8
2272:  MOVFF  98,A7
2276:  CLRF   xAA
2278:  MOVLW  9E
227A:  MOVWF  xA9
227C:  BRA    1CBE
....................                                 /* get temperature value as float */ 
....................                                 temperature_float = DS1820_GetTempFloat(); 
227E:  BRA    1EAE
2280:  MOVFF  03,9D
2284:  MOVFF  02,9C
2288:  MOVFF  01,9B
228C:  MOVFF  00,9A
....................                                 /* print result to RS232 interface  
....................                                 printf("Sensor %d: %sï¿½C (temperature_float = %f), temperature_raw = %ld)\n\r", 
....................                                 sensor_count, 
....................                                 temperature, 
....................                                 temperature_float, 
....................                                 temperature_raw); 
....................                                 */ 
....................                                 if (sensor_count > 0){ 
2290:  MOVF   xA6,F
2292:  BZ    229C
....................                                         printf(usb_cdc_putc,","); 
2294:  MOVLW  2C
2296:  MOVWF  xB4
2298:  CALL   1146
....................                                 } 
....................                                 printf(usb_cdc_putc,"\"%d\":\"%3.1f\"",sensor_count,temperature_float);   
229C:  MOVLW  22
229E:  MOVWF  xB4
22A0:  CALL   1146
22A4:  MOVFF  A6,A7
22A8:  MOVLW  18
22AA:  MOVWF  xA8
22AC:  CALL   16DC
22B0:  MOVLW  09
22B2:  MOVWF  FF6
22B4:  MOVLW  10
22B6:  MOVWF  FF7
22B8:  MOVLW  03
22BA:  MOVWF  xA7
22BC:  BRA    1EEA
22BE:  MOVLW  02
22C0:  MOVWF  FE9
22C2:  MOVFF  9D,AA
22C6:  MOVFF  9C,A9
22CA:  MOVFF  9B,A8
22CE:  MOVFF  9A,A7
22D2:  MOVLW  01
22D4:  MOVWF  xAB
22D6:  BRA    20CE
22D8:  MOVLW  22
22DA:  MOVWF  xB4
22DC:  CALL   1146
....................                                 sensor_count ++; 
22E0:  INCF   xA6,F
....................                         } 
....................                 while ( DS1820_FindNextDevice() ); 
22E2:  CALL   1864
22E6:  MOVF   01,F
22E8:  BNZ   2262
....................                 printf(usb_cdc_putc,"}"); 
22EA:  MOVLW  7D
22EC:  MOVWF  xB4
22EE:  CALL   1146
....................                 sensor_count = 0; 
22F2:  CLRF   xA6
....................                  
....................         } 
22F4:  GOTO   2476 (RETURN)
.................... } 
....................  
.................... ////////////////////////MAIN/////////////////////////////////////////////////////  
....................  
.................... void main(void) {  
22F8:  CLRF   FF8
22FA:  BCF    FD0.7
22FC:  BSF    07.7
22FE:  BSF    FB8.3
2300:  MOVLW  E1
2302:  MOVWF  FAF
2304:  MOVLW  04
2306:  MOVWF  FB0
2308:  MOVLW  A6
230A:  MOVWF  FAC
230C:  MOVLW  90
230E:  MOVWF  FAB
2310:  CLRF   25
2312:  CLRF   24
2314:  MOVLW  66
2316:  MOVWF  x87
2318:  MOVWF  x88
231A:  MOVF   FC1,W
231C:  ANDLW  C0
231E:  IORLW  0F
2320:  MOVWF  FC1
2322:  MOVLW  07
2324:  MOVWF  FB4
2326:  BCF    1A.0
2328:  BCF    1A.0
232A:  CLRF   1B
232C:  CLRF   1C
232E:  CLRF   1D
2330:  CLRF   1E
2332:  CLRF   1F
2334:  CLRF   20
2336:  CLRF   21
2338:  CLRF   22
233A:  CLRF   23
233C:  CLRF   2A
233E:  MOVLW  04
2340:  MOVWF  2B
2342:  MOVLW  0C
2344:  MOVWF  2C
2346:  CLRF   x85
2348:  CLRF   x86
234A:  CLRF   x93
234C:  CLRF   x94
234E:  CLRF   x95
2350:  CLRF   x97
....................    char c;  
....................     
....................    int8 numDev = 0; 
....................     
....................    // Find devices on the one wire bus  
....................    //numDev = FindDevices(); 
....................  
....................    beep(); 
2352:  CALL   103C
....................  
....................    LED_OFF(LED_GREEN); 
2356:  BCF    F96.2
2358:  BSF    F8D.2
....................    LED_OFF(LED_RED); 
235A:  BCF    F94.0
235C:  BSF    F8B.0
....................      
....................   // usb_token_reset(); 
....................    usb_init_cs(); 
235E:  GOTO   107A
....................  
....................  
.................... /* 
....................     //for  10 bit resolution mod   
....................     onewire_write(0xCC);  
....................     onewire_write(0x4E);  
....................  
....................     onewire_write(125);  
....................     onewire_write(-55); //this should be done for proper working of DS18B20  
....................     onewire_write(127);  
....................  
....................     onewire_reset();  
....................     onewire_write(0xCC);  
....................     onewire_write(0x48);  
....................     delay_ms(15);  
.................... */ 
....................  
....................  
....................    while (TRUE) {  
....................       usb_task();  
2362:  GOTO   10AE
....................       usb_debug_task();  
2366:  GOTO   1178
....................  
....................       if (kbhit()) {  
236A:  BTFSS  F9E.5
236C:  BRA    237E
....................          //odebranie z uart znaku 
....................          c=getc();  
236E:  BTFSS  F9E.5
2370:  BRA    236E
2372:  MOVFF  FAE,96
....................          //przekazanie znaku na usb 
....................          usb_cdc_putc(c); 
2376:  MOVFF  96,B4
237A:  CALL   1146
....................       }  
....................       if (usb_cdc_kbhit()) {  
237E:  BTFSS  2D.0
2380:  BRA    249E
....................  
....................          c=usb_cdc_getc();  
2382:  CALL   11DE
2386:  MOVFF  01,96
....................  
....................          switch (c){ 
238A:  MOVF   x96,W
238C:  XORLW  6D
238E:  BZ    23BE
2390:  XORLW  03
2392:  BZ    23C8
2394:  XORLW  1D
2396:  BZ    23D2
2398:  XORLW  06
239A:  BZ    23D8
239C:  XORLW  11
239E:  BZ    23DE
23A0:  XORLW  08
23A2:  BZ    23E4
23A4:  XORLW  1E
23A6:  BZ    23EA
23A8:  XORLW  1D
23AA:  BZ    23F0
23AC:  XORLW  16
23AE:  BZ    23FA
23B0:  XORLW  0D
23B2:  BZ    2474
23B4:  XORLW  04
23B6:  BZ    247C
23B8:  XORLW  08
23BA:  BZ    2492
23BC:  BRA    249E
....................                    case 'm': relay1(); blink_green(); break; 
23BE:  GOTO   1212
23C2:  CALL   122E
23C6:  BRA    249E
....................                    case 'n': relay2(); blink_green(); break; 
23C8:  GOTO   126A
23CC:  CALL   122E
23D0:  BRA    249E
....................                    case 's': beep(); break; 
23D2:  CALL   103C
23D6:  BRA    249E
....................                    case 'u': up(); break; 
23D8:  GOTO   1286
23DC:  BRA    249E
....................                    case 'd': down(); break; 
23DE:  GOTO   12A0
23E2:  BRA    249E
....................                    case 'l': left(); break; 
23E4:  GOTO   12BA
23E8:  BRA    249E
....................                    case 'r': right(); break; 
23EA:  GOTO   12D4
23EE:  BRA    249E
....................                    case 'o': set_time(); blink_green(); break; 
23F0:  GOTO   1476
23F4:  CALL   122E
23F8:  BRA    249E
....................                    case 'y': read_time(); printf (usb_cdc_putc,"%d-%d-%d %d:%d:%d", day, month, year, hour, min, sec); blink_green(); break; 
23FA:  GOTO   1662
23FE:  MOVFF  90,A7
2402:  MOVLW  18
2404:  MOVWF  xA8
2406:  CALL   16DC
240A:  MOVLW  2D
240C:  MOVWF  xB4
240E:  CALL   1146
2412:  MOVFF  91,A7
2416:  MOVLW  18
2418:  MOVWF  xA8
241A:  CALL   16DC
241E:  MOVLW  2D
2420:  MOVWF  xB4
2422:  CALL   1146
2426:  MOVFF  92,A7
242A:  MOVLW  18
242C:  MOVWF  xA8
242E:  CALL   16DC
2432:  MOVLW  20
2434:  MOVWF  xB4
2436:  CALL   1146
243A:  MOVFF  8F,A7
243E:  MOVLW  18
2440:  MOVWF  xA8
2442:  CALL   16DC
2446:  MOVLW  3A
2448:  MOVWF  xB4
244A:  CALL   1146
244E:  MOVFF  8E,A7
2452:  MOVLW  18
2454:  MOVWF  xA8
2456:  CALL   16DC
245A:  MOVLW  3A
245C:  MOVWF  xB4
245E:  CALL   1146
2462:  MOVFF  8D,A7
2466:  MOVLW  18
2468:  MOVWF  xA8
246A:  CALL   16DC
246E:  CALL   122E
2472:  BRA    249E
....................                    case 't':  
....................                              json_temp(); 
2474:  BRA    2250
....................                              blink_green(); 
2476:  CALL   122E
....................                              break; 
247A:  BRA    249E
....................                    case 'p': printf(usb_cdc_putc, "ok");  blink_green(); break; 
247C:  MOVLW  6F
247E:  MOVWF  xB4
2480:  CALL   1146
2484:  MOVLW  6B
2486:  MOVWF  xB4
2488:  CALL   1146
248C:  CALL   122E
2490:  BRA    249E
....................                    case 'x':  beep(); blink_green(); reset_cpu(); break; 
2492:  CALL   103C
2496:  CALL   122E
249A:  RESET
249C:  BRA    249E
....................                    default: /*putc(c);*/ break; 
....................          } 
....................      }  
249E:  BRA    2362
....................    }  
.................... } 
24A0:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
